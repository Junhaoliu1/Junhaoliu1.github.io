

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="liujunhao">
  <meta name="keywords" content="">
  
    <meta name="description" content="[TOC] Python常见输入输出格式1、输入 将输入存放进整数a， b  11 2   格式  1a, b &#x3D; map(int, input().split())     将输入存放进数组  11 2 3 4   格式  1li &#x3D; list(map(int, input().split()))    2、输出 输出数组数据  11 2 3 4   格式  123print(&quot; &amp;q">
<meta property="og:type" content="article">
<meta property="og:title" content="acwing算法基础课笔记总结">
<meta property="og:url" content="http://example.com/2025/04/11/acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="虾仁猪心">
<meta property="og:description" content="[TOC] Python常见输入输出格式1、输入 将输入存放进整数a， b  11 2   格式  1a, b &#x3D; map(int, input().split())     将输入存放进数组  11 2 3 4   格式  1li &#x3D; list(map(int, input().split()))    2、输出 输出数组数据  11 2 3 4   格式  123print(&quot; &amp;q">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/blog1/post.png">
<meta property="article:published_time" content="2025-04-11T03:01:48.000Z">
<meta property="article:modified_time" content="2025-04-11T03:05:10.406Z">
<meta property="article:author" content="liujunhao">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/blog1/post.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>acwing算法基础课笔记总结 - 虾仁猪心</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>虾仁猪心&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="acwing算法基础课笔记总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        liujunhao
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-11 11:01" pubdate>
          2025年4月11日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          44k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          365 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">acwing算法基础课笔记总结</h1>
            
            
              <div class="markdown-body">
                
                <p>[TOC]</p>
<h1 id="Python常见输入输出格式"><a href="#Python常见输入输出格式" class="headerlink" title="Python常见输入输出格式"></a>Python常见输入输出格式</h1><h2 id="1、输入"><a href="#1、输入" class="headerlink" title="1、输入"></a>1、输入</h2><ul>
<li>将输入存放进整数a， b</li>
</ul>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>格式</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-built_in">map</span>(int, <span class="hljs-selector-tag">input</span>()<span class="hljs-selector-class">.split</span>())<br></code></pre></td></tr></table></figure>



<ul>
<li>将输入存放进数组</li>
</ul>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<ul>
<li>格式</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">li</span> = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(int, <span class="hljs-selector-tag">input</span>()<span class="hljs-selector-class">.split</span>()))<br></code></pre></td></tr></table></figure>



<h2 id="2、输出"><a href="#2、输出" class="headerlink" title="2、输出"></a>2、输出</h2><ul>
<li>输出数组数据</li>
</ul>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<ul>
<li>格式</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-keyword">map</span>(str, <span class="hljs-keyword">q</span>)))  <span class="hljs-comment"># q是数组</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">q[i]</span>, end = <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">print</span>()           <span class="hljs-comment"># 相当于换行符</span><br></code></pre></td></tr></table></figure>



<ul>
<li>输出含空格的一行数</li>
</ul>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>格式</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.format(a, b)</span></span>)<br></code></pre></td></tr></table></figure>



<ul>
<li>输出几位小数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.6f&quot;</span> %x)<br></code></pre></td></tr></table></figure>



<h2 id="3、输入二维数组"><a href="#3、输入二维数组" class="headerlink" title="3、输入二维数组"></a>3、输入二维数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">1010</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()) <span class="hljs-comment"># n * m</span><br>a = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>	a[i][<span class="hljs-number">0</span>:m+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br></code></pre></td></tr></table></figure>



<h2 id="4、转换"><a href="#4、转换" class="headerlink" title="4、转换"></a>4、转换</h2><ul>
<li>‘A’ - &gt; 对应数字</li>
</ul>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;A&#x27;</span>)</span><br></code></pre></td></tr></table></figure>



<ul>
<li>‘1’ -&gt;1       注意1不是‘1’对应的数字，如果‘1’要转换为对应数字，也要ord</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-string">&#x27;1&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure>



<ul>
<li>1 -&gt;‘1’</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure>



<ul>
<li>65 -&gt;‘A’</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">chr</span><span class="hljs-params">(<span class="hljs-number">65</span>)</span></span><br></code></pre></td></tr></table></figure>



<h2 id="5、日期"><a href="#5、日期" class="headerlink" title="5、日期"></a>5、日期</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> *<br>s = datetime(<span class="hljs-number">1900</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>e = datetime(<span class="hljs-number">9999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>)<br>t = timedelta(days=<span class="hljs-number">1</span>)<br>summ = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> s &lt; e:<br>    y = <span class="hljs-built_in">int</span>(s.year)<br>    m = <span class="hljs-built_in">int</span>(s.month)<br>    d = <span class="hljs-built_in">int</span>(s.day)<br>    n = y//<span class="hljs-number">1000</span> + ((y//<span class="hljs-number">10</span>) % <span class="hljs-number">10</span>) + y % <span class="hljs-number">10</span> + ((y//<span class="hljs-number">100</span>) % <span class="hljs-number">10</span>)<br>    m = m % <span class="hljs-number">10</span> + m//<span class="hljs-number">10</span> + d % <span class="hljs-number">10</span> + d//<span class="hljs-number">10</span><br>    <span class="hljs-keyword">if</span> m == n:<br>        summ += <span class="hljs-number">1</span><br>    s += t<br><span class="hljs-built_in">print</span>(summ)<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">print(70910)</span><br></code></pre></td></tr></table></figure>





<h1 id="一、算法基础"><a href="#一、算法基础" class="headerlink" title="一、算法基础"></a>一、算法基础</h1><h2 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h2><h3 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h3><ul>
<li>将原集合一分为二</li>
<li>分别对两个子集合进行排序（递归的归并排序）</li>
<li>将两个排序后有序的子集合合并</li>
</ul>
<h4 id="1-1、原型"><a href="#1-1、原型" class="headerlink" title="1.1、原型"></a>1.1、原型</h4><ul>
<li>题目：</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定你一个长度为 <span class="hljs-built_in">n</span>的整数数列。<br>请你使用归并排序对这个数列按照从小到大进行排序。<br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>,第二行包含 <span class="hljs-built_in">n</span>个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span>范围内），表示整个数列。<br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span>个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<ul>
<li>解答</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N], temp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-comment">//找中值</span><br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">//分段排序</span><br>    <span class="hljs-built_in">mergesort</span>(q, left, mid);<br>    <span class="hljs-built_in">mergesort</span>(q, mid + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-comment">//合并， 在temp中k从left开始</span><br>    <span class="hljs-type">int</span> k = left, i = left, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt; q[j])<br>            temp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span><br>            temp[k++] = q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)<br>        temp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= right)<br>        temp[k++] = q[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt;= right; i++)<br>    &#123;<br>        q[i] = temp[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; q[i];<br>    &#125;<br>    <span class="hljs-built_in">mergesort</span>(q, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mergesort</span>(<span class="hljs-params">q, left, right</span>):<br>    <span class="hljs-keyword">if</span> left &gt;= right:<br>        <span class="hljs-keyword">return</span><br>    mid = (left+right) // <span class="hljs-number">2</span><br>    mergesort(q, left, mid)<br>    mergesort(q, mid+<span class="hljs-number">1</span>, right)<br>    <br>    i = left<br>    j = mid+<span class="hljs-number">1</span><br>    temp = []<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) <span class="hljs-keyword">and</span> (j &lt;= right):<br>        <span class="hljs-keyword">if</span> q[i] &lt;= q[j]:<br>            temp.append(q[i])<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            temp.append(q[j])<br>            j += <span class="hljs-number">1</span><br>    temp += q[i:mid+<span class="hljs-number">1</span>]<br>    temp += q[j:right+<span class="hljs-number">1</span>]<br>    q[left:right+<span class="hljs-number">1</span>] = temp<br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    q = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br>    mergesort(q, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, q)))        <span class="hljs-comment"># 注意输出格式，1 2 3 4 5</span><br></code></pre></td></tr></table></figure>





<h4 id="1-2、变式（逆序对个数）"><a href="#1-2、变式（逆序对个数）" class="headerlink" title="1.2、变式（逆序对个数）"></a>1.2、变式（逆序对个数）</h4><ul>
<li>题目：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">给定一个长度为 n的整数数列，请你计算数列中的逆序对的数量。<br><br>逆序对的定义如下：对于数列的第 <span class="hljs-selector-tag">i</span>个和第 j个元素，如果满足 <span class="hljs-selector-tag">i</span>&lt;j且 <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>&gt;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[j]</span>，则其为一个逆序对；否则不是。<br><br>输入格式<br>第一行包含整数 n，表示数列的长度。<br><br>第二行包含 n个整数，表示整个数列。<br><br>输出格式<br>输出一个整数，表示逆序对的个数。<br><br>数据范围<br><span class="hljs-number">1</span>≤n≤<span class="hljs-number">100000</span>，数列中的元素的取值范围 <span class="hljs-selector-attr">[1,109]</span>。<br><br>输入样例：<br><span class="hljs-number">6</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span><br>输出样例：<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<ul>
<li>思路</li>
</ul>
<p>​        运用归并排序中的合并步骤统计逆序对的对数，若q[l] &gt; q[r] ,则左子数组从l到mid的元素均大于q[r]，它们都可以和q[r]组成逆序对，则cnt要加元素个数</p>
<ul>
<li>解答</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100001</span>;<br><span class="hljs-type">int</span> n, q[N], temp[N];<br><span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>;                         <span class="hljs-comment">//数据太大了，要变为long类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergesort</span>(left, mid);<br>    <span class="hljs-built_in">mergesort</span>(mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = left;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])        <span class="hljs-comment">//注意合并的条件是array[lptr] &lt;= array[rptr]而y总的模板里面是小于，少了等号会导致相同的数也被计算了数对</span><br>            temp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            temp[k++] = q[j++];<br>            cnt += (mid-i<span class="hljs-number">+1</span>);    <span class="hljs-comment">//左边子数组剩余未合并的元素个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)<br>        temp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= right)<br>        temp[k++] = q[j++];<br>    <span class="hljs-keyword">for</span>(k = left; k &lt;= right; k++)<br>        q[k] = temp[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; q[i];<br>    &#125;<br>    <span class="hljs-built_in">mergesort</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="2、二分算法"><a href="#2、二分算法" class="headerlink" title="2、二分算法"></a>2、二分算法</h3><h4 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h4><ul>
<li>有单调性一定可以二分，可以二分不一定有单调性</li>
<li>二分的本质是边界不是单调性(单调一定可以二分，不单调的有的也可以二分)</li>
</ul>
<p>本质：在一个区间上，找到某种性质，每次可以将区间一分为二（存在边界），一个区间满足、另外一个区间不满足，<code>答案就在边界上！</code></p>
<ul>
<li>注意循环条件和边界赋值</li>
</ul>
<h5 id="2-1-1-整数二分"><a href="#2-1-1-整数二分" class="headerlink" title="2.1.1 整数二分"></a>2.1.1 整数二分</h5><ul>
<li>分两种情况（对应模板一和模板二）</li>
</ul>
<img src="../../../Desktop/总/算法/算法图解/二分模板分类.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />

<ul>
<li>情况一（模板一）找左端点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b_search1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)    <br>    &#123;<br>    	<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))<br>        	r = mid;<br>        <span class="hljs-keyword">else</span> <br>        	l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模板一对应绿色段的情况</p>
<ul>
<li>情况二   (模板二)找右端点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b_seaech2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;   <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))<br>            l = mid;     <span class="hljs-comment">//上边mid加1，是为了防止出现l=l的无效更新情况，因为若不加一，当l=r-1时，mid = (l+r)/2 = l,此时l=l是无效更新</span><br>        <span class="hljs-keyword">else</span> <br>            r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模板二对应红色段，注意此时更新mid时需要额外+1防止死循环， 设 l &#x3D; r-1， 若不加一，mid &#x3D; l， 则l &#x3D; l ， 一直结束不了循环</p>
<p><strong>两种情况都一定会有解， 且都是l &#x3D; r， 即l和r 都是解</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>





<h5 id="2-1-2-浮点数二分"><a href="#2-1-2-浮点数二分" class="headerlink" title="2.1.2 浮点数二分"></a>2.1.2 浮点数二分</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b_search</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>((r - l ) &gt;  <span class="hljs-number">1e-6</span>) <br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) <br>            r = mid;<br>        <span class="hljs-keyword">else</span> <br>            l = mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-2、例题"><a href="#2-2、例题" class="headerlink" title="2.2、例题"></a>2.2、例题</h4><h5 id="2-2-1、例一"><a href="#2-2-1、例一" class="headerlink" title="2.2.1、例一"></a>2.2.1、例一</h5><ul>
<li>题目</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">给定一个按照升序排列的长度为 n的整数数组，以及 <span class="hljs-selector-tag">q</span>个查询。<br>对于每个查询，返回一个元素 k的起始位置和终止位置（位置从 <span class="hljs-number">0</span>开始计数）。<br>如果数组中不存在该元素，则返回 -<span class="hljs-number">1</span> -<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 n和 <span class="hljs-selector-tag">q</span>，表示数组长度和询问个数。<br>第二行包含 n个整数（均在 <span class="hljs-number">1</span>∼<span class="hljs-number">10000</span>范围内），表示完整数组。<br>接下来 <span class="hljs-selector-tag">q</span>行，每行包含一个整数 k，表示一个询问元素。<br><br>输出格式共 <span class="hljs-selector-tag">q</span>行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回 -<span class="hljs-number">1</span> -<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure>

<ul>
<li>思路</li>
</ul>
<p>找下标， 相当于找&gt;&#x3D;x的左边界，也就是绿色段的左边界； 找上标， 相当于找&lt;&#x3D;x 的右边界</p>
<ul>
<li>解答</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;    <span class="hljs-comment">//1000010 也可写为1e6 + 10</span><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; q[i];<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;                   <span class="hljs-comment">//目标数据</span><br>        cin &gt;&gt; x;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid] &gt;= x)<br>                r = mid;<br>            <span class="hljs-keyword">else</span><br>                l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q[l] != x)<br>            cout &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>            l = <span class="hljs-number">0</span>;<br>            r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid] &lt;= x)<br>                    l = mid;<br>                <span class="hljs-keyword">else</span><br>                    r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            cout &lt;&lt; l &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    q = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">while</span> m:<br>        m -= <span class="hljs-number">1</span><br>        x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>        l, r = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            mid = (r + l) &gt;&gt; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> q[mid] &gt;= x:<br>                r = mid<br>            <span class="hljs-keyword">else</span>:<br>                l = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> q[l] != x:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            left = l    <span class="hljs-comment"># 存储下界</span><br>            l, r = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r:<br>                mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span> <br>                <span class="hljs-keyword">if</span> q[mid] &lt;= x:<br>                    l = mid<br>                <span class="hljs-keyword">else</span>:<br>                    r = mid - <span class="hljs-number">1</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(left, l))<br></code></pre></td></tr></table></figure>



<h5 id="2-2-2、-例二"><a href="#2-2-2、-例二" class="headerlink" title="2.2.2、 例二"></a>2.2.2、 例二</h5><ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个浮点数 <span class="hljs-built_in">n</span>，求它的三次方根。<br><br>输入格式共一行，包含一个浮点数 <span class="hljs-built_in">n</span>。<br><br>输出格式<br>共一行，包含一个浮点数，表示问题的解。<br><br>注意，结果保留 <span class="hljs-number">6</span>位小数。<br><br>数据范围<br>−<span class="hljs-number">10000</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">-100000</span>, r = <span class="hljs-number">100000</span>;   <span class="hljs-comment">//注意立方根可能为负数</span><br>    <span class="hljs-keyword">while</span>((r - l) &gt; <span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid*mid &gt;= n)<br>            r = mid;<br>        <span class="hljs-keyword">else</span><br>            l = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>, l);      <span class="hljs-comment">//保留6位</span><br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    x = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>())<br>    l = -<span class="hljs-number">100000</span><br>    r = <span class="hljs-number">100000</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">abs</span>(l- r) &gt; <span class="hljs-number">1e-8</span>:<br>        mid = (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> mid**<span class="hljs-number">3</span> &gt; x:<br>            r = mid<br>        <span class="hljs-keyword">else</span>:<br>            l = mid<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%.6f&quot;</span> %l)<br></code></pre></td></tr></table></figure>





<h3 id="3、高精度算法（一般是整型变量）"><a href="#3、高精度算法（一般是整型变量）" class="headerlink" title="3、高精度算法（一般是整型变量）"></a>3、高精度算法（一般是整型变量）</h3><p>当整型变量位数非常大（超过10的6次方），用整型变量存储不了时，用高精度算法。</p>
<ul>
<li><p>存储：</p>
<p>  一般把数据用字符串输入，然后再存储进数组当中。</p>
</li>
<li><p>计算</p>
</li>
<li><p>输出</p>
</li>
</ul>
<h4 id="3-1、-高精度加法"><a href="#3-1、-高精度加法" class="headerlink" title="3.1、 高精度加法"></a>3.1、 高精度加法</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">给定两个正整数（不含前导 0），计算它们的和。<br><br>输入格式<br>共两行，每行包含一个整数。<br><br>输出格式<br>共一行，包含所求的和。<br><br>数据范围<br>1≤整数长度≤100000   <br></code></pre></td></tr></table></figure>

<p> 数据范围是长度小于1000000， 说明要用高精度算法</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;   <span class="hljs-comment">//进位信息</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>())<br>            t += A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>())<br>            t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t &gt; <span class="hljs-number">0</span>)<br>        C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-comment">//将1234转换为[4, 3, 2, 1]</span><br>        A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);       <span class="hljs-comment">//将字符类型转换为整型</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">add</span>(A, B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; i--)<br>        cout &lt;&lt; C[i];<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="3-2-高精度减法"><a href="#3-2-高精度减法" class="headerlink" title="3.2 高精度减法"></a>3.2 高精度减法</h4><ul>
<li><p>细节：</p>
<ul>
<li>要考虑A，B的大小关系，若B大于A， 则进行B - A， 输出时要多加一个负号</li>
<li>运算时对t &#x3D; A[i] - B[i] -t 进行分类讨论，若t &gt; 0，则说明无借位，直接push(t)，更新t &#x3D; 0； 若t &lt; 0, 则有借位， push(t + 10), 更新t为1</li>
<li>最后对C进行修饰，把可能存在的高位的0给去掉，如003 —&gt;3</li>
<li>为啥用vector,因为一开始不知道数组的大小</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>())                <span class="hljs-comment">//先比较长度</span><br>        <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(A[i] != B[i])               <span class="hljs-comment">//仅需比较第一个不相等的元素</span><br>                <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>())<br>            t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);   <span class="hljs-comment">//t大于0时相当于直接push t本身， t小于0时相当于push t+10，即把两种情况融合在一起</span><br>        <span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">0</span>)<br>            t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            t = <span class="hljs-number">1</span>;       <span class="hljs-comment">//注意不是更新为-1</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span> &amp;&amp; C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)   <span class="hljs-comment">//pop高位0</span><br>        C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A, B))<br>    &#123;<br>        C = <span class="hljs-built_in">sub</span>(A, B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            cout &lt;&lt; C[i];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        C = <span class="hljs-built_in">sub</span>(B, A);<br>        cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            cout &lt;&lt; C[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="3-3高精度乘法"><a href="#3-3高精度乘法" class="headerlink" title="3.3高精度乘法"></a>3.3高精度乘法</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个非负整数（不含前导 <span class="hljs-number">0</span>） <span class="hljs-selector-tag">A</span>和 <span class="hljs-selector-tag">B</span>，请你计算 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span> 的值。<br><br>输入格式共两行，第一行包含整数 <span class="hljs-selector-tag">A</span>，第二行包含整数 <span class="hljs-selector-tag">B</span>。<br><br>输出格式<br>共一行，包含 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span>的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">A</span>的长度≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">0</span>≤<span class="hljs-selector-tag">b</span>≤<span class="hljs-number">10000</span>               //注意<span class="hljs-selector-tag">b</span>不是高精度数<br></code></pre></td></tr></table></figure>



<ul>
<li><p>细节：</p>
<ul>
<li>注意乘数不是高精度数</li>
<li>最后退出for循环时要判断t的情况， 若t大于0， 则要插入他</li>
<li>最后要对C进行修饰，考虑它是否为0，若为0，可能输出00000……， 则要对其进行修饰，使其输出0</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>())<br>            t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)<br>        C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    C = <span class="hljs-built_in">mul</span>(A, b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        cout  &lt;&lt; C[i];<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="3-4-高精度除法"><a href="#3-4-高精度除法" class="headerlink" title="3.4 高精度除法"></a>3.4 高精度除法</h4><ul>
<li><p>细节</p>
<ul>
<li>若除数为0 ， 直接结束</li>
<li>除法从高位开始算，所得结果C是正向的，因此为了统一性， 我们再把得到的C给翻转了</li>
<li>要去除C的前导0</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        r = r*<span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)<br>        C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, C;<br>    <span class="hljs-type">int</span> b, r;<br>    string a;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- )<br>        A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    C = <span class="hljs-built_in">div</span>(A, b, r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        cout &lt;&lt; C[i];<br>    cout &lt;&lt; endl &lt;&lt; r;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4、前缀和算法"><a href="#4、前缀和算法" class="headerlink" title="4、前缀和算法"></a>4、前缀和算法</h3><h4 id="4-1、-概念"><a href="#4-1、-概念" class="headerlink" title="4.1、 概念"></a>4.1、 概念</h4><p>前缀和即为数组的前n项和，要多开辟一个前缀和数组，它的第i项即为原数组前i项的和， S[n] &#x3D; a[n] + S[n-1], 注意前缀和数组的0项默认为0， a数组从下标为1的项开始算。</p>
<h4 id="4-2、应用"><a href="#4-2、应用" class="headerlink" title="4.2、应用"></a>4.2、应用</h4><p>直接暴力求解会超时</p>
<h5 id="1-快速求数组第i项到第j项之和"><a href="#1-快速求数组第i项到第j项之和" class="headerlink" title="1 快速求数组第i项到第j项之和"></a>1 快速求数组第i项到第j项之和</h5><p><strong>S<del>i,j</del></strong> &#x3D; S[j] - S[i-1]</p>
<ul>
<li>题目</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">输入一个长度为 n的整数序列。<br><br>接下来再输入 m个询问，每个询问输入一对 l,<span class="hljs-attribute">r</span>。<br><br>对于每个询问，输出原序列中从第 l个数到第 <span class="hljs-attribute">r</span>个数的和。<br><br>输入格式<br>第一行包含两个整数 n和 m。<br><br>第二行包含 n个整数，表示整数数列。<br><br>接下来 m行，每行包含两个整数 l和 <span class="hljs-attribute">r</span>，表示一个询问的区间范围。<br><br>输出格式共 m行，每行输出一个询问的结果。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m, q[N], S[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; q[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        S[i] = S[i - <span class="hljs-number">1</span>] + q[i];     <span class="hljs-comment">//创建前缀和数组</span><br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        cout &lt;&lt; S[y] - S[x - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    a = [<span class="hljs-number">0</span>]*N<br>    s = [<span class="hljs-number">0</span>]*N<br>    a[<span class="hljs-number">1</span>:n+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        s[i] = a[i] + s[i-<span class="hljs-number">1</span>]<br>        <br>    <span class="hljs-keyword">while</span> m:<br>        m -= <span class="hljs-number">1</span><br>        l, r = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        res = s[r] - s[l-<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>





<h5 id="2求子矩阵和（直接暴力求解会超时）"><a href="#2求子矩阵和（直接暴力求解会超时）" class="headerlink" title="2求子矩阵和（直接暴力求解会超时）"></a>2求子矩阵和（直接暴力求解会超时）</h5><ul>
<li>题目</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入一个 n行 m列的整数矩阵，再输入 q个询问，每个询问包含四个整数 <span class="hljs-built_in">x1</span>,y1,<span class="hljs-built_in">x2</span>,y2，表示一个子矩阵的左上角坐标和右下角坐标。<br><br>对于每个询问输出子矩阵中所有数的和。<br><br>输入格式<br>第一行包含三个整数 n，m，q。<br><br>接下来 n行，每行包含 m个整数，表示整数矩阵。<br>接下来 q行，每行包含四个整数 <span class="hljs-built_in">x1</span>,y1,<span class="hljs-built_in">x2</span>,y2，表示一组询问。<br><br>输出格式<br>共 q行，每行输出一个询问的结果。<br></code></pre></td></tr></table></figure>

<ul>
<li><p>公式</p>
<ul>
<li>求前缀和数组公式：S[i][j] &#x3D; S[i-1][j] + S[i][j-1] - S[i-1][j-1]  + a[i][j]</li>
<li>求子矩阵公式（可画图理解，有点像容斥原理）：S &#x3D; S[x<del>2</del>][y<del>2</del>] - S[x<del>2</del>][y<del>1</del>-1]  - S[x<del>1</del>-1][y<del>2</del>] + S[x<del>1</del>-1][y<del>1</del>-1]</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1001</span>;<br><span class="hljs-type">int</span> n, m, q, a[N][N], S[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cin &gt;&gt; a[i][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            S[i][j] = S[i - <span class="hljs-number">1</span>][j] + S[i][j - <span class="hljs-number">1</span>] - S[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1, x2, y1, y2;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        cout &lt;&lt; S[x2][y2] - S[x2][y1 - <span class="hljs-number">1</span>] - S[x1 - <span class="hljs-number">1</span>][y2] + S[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>] &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1010</span>)<br>s = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>a = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m, q = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        a[i][<span class="hljs-number">1</span>:m+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>):<br>            s[i][j] = s[i][j-<span class="hljs-number">1</span>] + s[i-<span class="hljs-number">1</span>][j] - s[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + a[i][j]<br>    <br>    <span class="hljs-keyword">while</span> q:<br>        q -= <span class="hljs-number">1</span><br>        x1, y1, x2, y2 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        res = s[x2][y2] - s[x2][y1-<span class="hljs-number">1</span>] - s[x1-<span class="hljs-number">1</span>][y2] + s[x1-<span class="hljs-number">1</span>][y1-<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>





<h3 id="5、差分算法（可看作前缀和的逆运算）"><a href="#5、差分算法（可看作前缀和的逆运算）" class="headerlink" title="5、差分算法（可看作前缀和的逆运算）"></a>5、差分算法（可看作前缀和的逆运算）</h3><img src="../../../Desktop/总/算法/无标题.png" srcset="/img/loading.gif" lazyload alt="*无标题*" style="zoom:33%;" />

<p>就是将输入的数组a看作前缀和数组，那么它没有累加之前的数组就是差分数组b。</p>
<p>差分数组b[i]+c，会导致前缀和数组的第i号之后的元素全部加c</p>
<h4 id="5-1-例题一"><a href="#5-1-例题一" class="headerlink" title="5.1 例题一"></a>5.1 例题一</h4><ul>
<li>题目（简单来说就是将前缀和数组的[l, r]区间的数据都加上c）</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入一个长度为 <span class="hljs-built_in">n</span>的整数序列。<br><br>接下来输入 m个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r]之间的每个数加上 c。<br>请你输出进行完所有操作后的序列。<br><br>输入格式<br>第一行包含两个整数 <span class="hljs-built_in">n</span>和 m。<br><br>第二行包含 <span class="hljs-built_in">n</span>个整数，表示整数序列。<br><br>接下来 m行，每行包含三个整数 l，r，c，表示一个操作。<br><br>输出格式共一行，包含 <span class="hljs-built_in">n</span>个整数，表示最终序列。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m, a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[i] += k;<br>    b[j<span class="hljs-number">+1</span>] -= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">insert</span>(i, i, a[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> i, j, k;<br>        cin &gt;&gt; i &gt;&gt; j &gt;&gt; k;<br>        <span class="hljs-built_in">insert</span>(i, j, k);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        b[i] += b[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cout &lt;&lt; b[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>s = [<span class="hljs-number">0</span>] * N<br>a = [<span class="hljs-number">0</span>] * N<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    s[<span class="hljs-number">1</span>:n+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        a[i] = s[i] - s[i-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">while</span> m:<br>        m -= <span class="hljs-number">1</span><br>        l, r, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        a[l] += c<br>        a[r+<span class="hljs-number">1</span>] -= c<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        s[i] = s[i-<span class="hljs-number">1</span>] + a[i]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, s[<span class="hljs-number">1</span>:n+<span class="hljs-number">1</span>])))<br></code></pre></td></tr></table></figure>



<ul>
<li>细节<ul>
<li>先得到差分数组，然后对差分数组进行操作，最后得到修改的前缀和数组</li>
<li>如何得到差分数组？先将差分数组全初始化为0，一个个元素插入，插入第i个元素就相当于为前缀和数组的[i, i]区间增加c</li>
<li>核心操作是差分数组的  b[l] + c,  b[r + 1] - c</li>
<li>由差分数组得到前缀和数组：在差分数组上原地操作，b[i] +&#x3D; b[i-1]；    得到新的前缀和数组a[i] &#x3D; a[i - 1] + b[i]</li>
</ul>
</li>
</ul>
<h4 id="5-2-例题二"><a href="#5-2-例题二" class="headerlink" title="5.2 例题二"></a>5.2 例题二</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入一个 n行 m列的整数矩阵，再输入 q个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 。<br><br>请你将进行完所有操作后的矩阵输出。<br><br>输入格式<br>第一行包含整数 n,m,q。<br><br>接下来 n行，每行包含 m个整数，表示整数矩阵。<br><br>接下来 q行，每行包含 <span class="hljs-number">5</span>个整数 x1,y1,x2,y2,c，表示一个操作。<br><br>输出格式共 n行，每行 m个整数，表示所有操作进行完毕后的最终矩阵。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m, q, a[N][N], b[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2<span class="hljs-number">+1</span>] -= c;<br>    b[x2<span class="hljs-number">+1</span>][y1] -= c;<br>    b[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cin &gt;&gt; a[i][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2, c;<br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(x1, y1, x2, y2, c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            b[i][j] += (b[i<span class="hljs-number">-1</span>][j] + b[i][j<span class="hljs-number">-1</span>] - b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            cout &lt;&lt; b[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">1010</span><br>s = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>a = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">x1, y1, x2, y2, c</span>):<br>    a[x1][y1] += c<br>    a[x2+<span class="hljs-number">1</span>][y1] -= c<br>    a[x1][y2+<span class="hljs-number">1</span>] -= c<br>    a[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += c<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        s[i][<span class="hljs-number">1</span>:m+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            insert(i, j, i, j, s[i][j]);<br>    <span class="hljs-keyword">while</span> k:<br>        k -= <span class="hljs-number">1</span><br>        x1, y1, x2, y2, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        insert(x1, y1, x2, y2, c)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>):<br>            s[i][j] = s[i-<span class="hljs-number">1</span>][j] + s[i][j-<span class="hljs-number">1</span>] - s[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + a[i][j]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, s[i][<span class="hljs-number">1</span>:m+<span class="hljs-number">1</span>])))<br></code></pre></td></tr></table></figure>



<ul>
<li>原理</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5.png" srcset="/img/loading.gif" lazyload alt="g"></p>
<ul>
<li>如何得到差分矩阵，相当于插入一个个小矩阵，insert(i,j,i,j,c)</li>
</ul>
<h3 id="6、-双指针算法"><a href="#6、-双指针算法" class="headerlink" title="6、 双指针算法"></a>6、 双指针算法</h3><ul>
<li>将复杂度为n^2的算法优化为n</li>
</ul>
<h4 id="6-1、-例一-最长连续不重复子序列"><a href="#6-1、-例一-最长连续不重复子序列" class="headerlink" title="6.1、 例一 最长连续不重复子序列"></a>6.1、 例一 最长连续不重复子序列</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个长度为 <span class="hljs-built_in">n</span>的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>。<br>第二行包含 <span class="hljs-built_in">n</span>个整数（均在 <span class="hljs-number">0</span>∼<span class="hljs-number">105</span>范围内），表示整数序列。<br><br>输出格式<br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, res = <span class="hljs-number">0</span>, a[N], S[N];    <span class="hljs-comment">//S数组用于动态记录每个数的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        S[a[i]]++;<br>        <span class="hljs-keyword">while</span>(S[a[i]] &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            S[a[j]]--;<br>            j++;<br>        &#125;<br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>s = [<span class="hljs-number">0</span>]*N<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    res = <span class="hljs-number">0</span><br>    i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; n:<br>        s[a[i]] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> s[a[i]] &gt; <span class="hljs-number">1</span>:<br>            s[a[j]] -= <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br>        res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>)<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<ul>
<li>原理</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload alt="双指针解决连续子序列问题"></p>
<h4 id="6-2题二"><a href="#6-2题二" class="headerlink" title="6.2题二"></a>6.2题二</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">给定两个升序排序的有序数组 A和 B，以及一个目标值 <span class="hljs-attribute">x</span>。<br>数组下标从 <span class="hljs-number">0</span>开始。<br><br>请你求出满足 A<span class="hljs-selector-attr">[i]</span>+B<span class="hljs-selector-attr">[j]</span>=<span class="hljs-attribute">x</span>的数对 (i,j)。<br><br>数据保证有唯一解。<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    b = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    i, j = <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; n) <span class="hljs-keyword">and</span> (j &gt;= <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">if</span> a[i] + b[j] == k:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, j))<br>            <span class="hljs-keyword">break</span>                <span class="hljs-comment"># 注意要break，不然一直卡在这</span><br>        <span class="hljs-keyword">elif</span> a[i] + b[j] &lt; k:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            j -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>







<h3 id="7、-位运算-lowbit"><a href="#7、-位运算-lowbit" class="headerlink" title="7、 位运算(lowbit)"></a>7、 位运算(lowbit)</h3><ul>
<li>lowbit(x) 是找到二进制下x的最后一位1的大小，如10 （十进制）&#x3D; 1010（二进制），lowbit(10) &#x3D; 10 &#x3D; 2</li>
<li>lowbit(x) 本质是x &amp; -x  &#x3D;&#x3D;&gt; x &amp; (~x +1) </li>
<li>&amp;要1和1的情况下才为1</li>
<li>例题</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个长度为 <span class="hljs-built_in">n</span>的数列，请你求出数列中每个数的二进制表示中 <span class="hljs-number">1</span>的个数。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span>个整数，表示整个数列。<br><br>输出格式<br>共一行，包含 <span class="hljs-built_in">n</span>个整数，其中的第 i个数表示数列中的第 i个数的二进制表示中 <span class="hljs-number">1</span>的个数。<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =  <span class="hljs-number">100000</span>;<br><span class="hljs-type">int</span> n, x, res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>    &#123;<br>        cin &gt;&gt; x;<br>        res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)<br>        &#123;<br>            x -= <span class="hljs-built_in">lowbit</span>(x);<br>            res++;<br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lowbit</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x &amp; -x<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    q = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    res = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q[i]:<br>            q[i] -= lowbit(q[i])<br>            cnt += <span class="hljs-number">1</span><br>        res.append(cnt)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, res)))<br></code></pre></td></tr></table></figure>





<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="1、链表"><a href="#1、链表" class="headerlink" title="1、链表"></a>1、链表</h3><p>动态链表每次new一个空间太慢了，因此这里我们用数组来模拟静态链表</p>
<h4 id="1-1单链表"><a href="#1-1单链表" class="headerlink" title="1.1单链表"></a>1.1单链表</h4><ul>
<li>用途：邻接表存储图</li>
<li>实现基础：两个数组  data[]存储数据， next[]存储下一个元素的下标</li>
<li>题目：</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">实现一个单链表，链表初始为空，支持三种操作：<br>向链表头插入一个数；<br>删除第 k个插入的数后面的一个数；<br>在第 k个插入的数后插入一个数。<br><br>现在要对该链表进行 M次操作，进行完所有操作后，从头到尾输出整个链表。<br><br>注意<span class="hljs-symbol">:</span>题目中第 k个插入的数并不是指当前链表的第 k个数。例如操作过程中一共插入了 <span class="hljs-built_in">n</span>个数，则按照插入的时间顺序，这 <span class="hljs-built_in">n</span>个数依次为：第 <span class="hljs-number">1</span>个插入的数，第 <span class="hljs-number">2</span>个插入的数，…第 <span class="hljs-built_in">n</span>个插入的数。<br><br>输入格式<br>第一行包含整数 ，表示操作次数。<br><br>接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：<br>H x，表示向链表头插入一个数 x。<br>D k，表示删除第 k个插入的数后面的数（当 k为 <span class="hljs-number">0</span>时，表示删除头结点）。<br>I k x，表示在第 k个插入的数后面插入一个数 （此操作中 k均大于 <span class="hljs-number">0</span>）。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> e[N], head, tail;  <br><span class="hljs-type">int</span> ne[N];<br><br><span class="hljs-comment">//head是第一个元素的下标</span><br><span class="hljs-comment">//tail是当前可插入的位置的下标,不要被名字骗了，它并不是指向链表的尾部</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    tail = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[tail] = x;<br>    ne[tail] = head;<br>    head = tail;<br>    tail++;<br>&#125;<br><br><span class="hljs-comment">//删除下标为k的元素的下一个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br><br><span class="hljs-comment">//在下标为k的点后边插入一个点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[tail] = x;<br>    ne[tail] = ne[k];<br>    ne[k] = tail;<br>    tail++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> M, k, x;<br>    cin &gt;&gt; M;<br>    <span class="hljs-keyword">while</span>(M--)<br>    &#123;<br>        <span class="hljs-type">char</span> cnt;<br>        cin &gt;&gt; cnt;<br>        <span class="hljs-keyword">if</span>(cnt == <span class="hljs-string">&#x27;H&#x27;</span>)<br>        &#123;<br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">add_to_head</span>(x);<br>        &#125;<br>        <span class="hljs-comment">//注意是删除第k个插入的点后边的点，第k个插入的点的下标应该是k-1</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            cin &gt;&gt; k &gt;&gt; x;<br>            <span class="hljs-built_in">insert</span>(k - <span class="hljs-number">1</span>, x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cin &gt;&gt; k;<br>            <span class="hljs-keyword">if</span>(!k) head = ne[head];<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(k - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>e = [<span class="hljs-number">0</span>] * N<br>ne = [<span class="hljs-number">0</span>] * N<br>head, tail = -<span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> head, tail<br>    e[tail] = x<br>    ne[tail] = head<br>    head = tail<br>    tail += <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">k, x</span>):<br>    <span class="hljs-keyword">global</span> tail<br>    e[tail] = x<br>    ne[tail] = ne[k]<br>    ne[k] = tail<br>    tail += <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">k</span>):<br>    ne[k] = ne[ne[k]]<br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        li = <span class="hljs-built_in">input</span>().split()<br>        <span class="hljs-keyword">if</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;H&quot;</span>:<br>            x = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>])<br>            add(x)<br>        <span class="hljs-keyword">elif</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;D&quot;</span>:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>                head = ne[head]<br>            x = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>])<br>            remove(x-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            k, x = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(li[<span class="hljs-number">2</span>])<br>            insert(k-<span class="hljs-number">1</span>, x)<br>    i = head<br>    res = []<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        res.append(e[i])<br>        i = ne[i]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, res)))<br></code></pre></td></tr></table></figure>



<h4 id="1-2双链表"><a href="#1-2双链表" class="headerlink" title="1.2双链表"></a>1.2双链表</h4><ul>
<li>用途：优化某些问题</li>
<li>题目</li>
</ul>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gml">实现一个双链表，双链表初始为空，支持 <span class="hljs-number">5</span>种操作：<br>在最左侧插入一个数；<br>在最右侧插入一个数；<br>将第 k个插入的数删除；<br>在第 k个插入的数左侧插入一个数；<br>在第 k个插入的数右侧插入一个数<br>现在要对该链表进行 M次操作，进行完所有操作后，从左到右输出整个链表。<br><br>注意:题目中第 k个插入的数并不是指当前链表的第 k个数。例如操作过程中一共插入了 n个数，则按照插入的时间顺序，这 n个数依次为：第 <span class="hljs-number">1</span>个插入的数，第 <span class="hljs-number">2</span>个插入的数，…第 n个插入的数。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M行，每行包含一个操作命令，操作命令可能为以下几种：<br>L <span class="hljs-variable language_">x</span>，表示在链表的最左端插入数 <span class="hljs-variable language_">x</span>。<br>R <span class="hljs-variable language_">x</span>，表示在链表的最右端插入数 <span class="hljs-variable language_">x</span>。<br>D k，表示将第 k个插入的数删除。<br>IL k <span class="hljs-variable language_">x</span>，表示在第 k个插入的数左侧插入一个数。<br>IR k <span class="hljs-variable language_">x</span>，表示在第 k个插入的数右侧插入一个数。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">//初始化，0被当成最右边结点，1被当成最左边结点，不储存数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 头指针</span><br>    l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 尾指针</span><br>    idx = <span class="hljs-number">2</span>;   <span class="hljs-comment">//从下标为2的位置开始可以插入结点</span><br>&#125;<br><br><span class="hljs-comment">//e[]用来存储数值</span><br><span class="hljs-comment">//l[]用来存储前驱(左边数的下标)</span><br><span class="hljs-comment">//r[]用来存储后继(右边数的下标)</span><br><span class="hljs-comment">//idx用来记录当前可插入的位置的下标</span><br><br><span class="hljs-comment">//在最左边插入x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_most_left</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = <span class="hljs-number">0</span>;<br>    r[idx] = r[<span class="hljs-number">0</span>];<br>    r[<span class="hljs-number">0</span>] = idx;<br>    l[r[idx]] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-comment">//在最右边插入x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_most_right</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    r[idx] = <span class="hljs-number">1</span>;<br>    l[idx] = l[<span class="hljs-number">1</span>];<br>    l[<span class="hljs-number">1</span>] = idx;<br>    r[l[idx]] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-comment">//删除下标为k的结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br><br><span class="hljs-comment">//在下标为k的结点左边插入数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_left</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    r[idx] = k;<br>    l[idx] = l[k];<br>    l[k] = idx;<br>    r[l[idx]] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-comment">//在下标为k的结点右边插入数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_right</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = k;<br>    r[idx] = r[k];<br>    r[k] = idx;<br>    l[r[idx]] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> M;<br>    cin &gt;&gt; M;<br>    <span class="hljs-keyword">while</span>(M--)<br>    &#123;<br>        <span class="hljs-type">int</span> k, x;<br>        string a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">add_most_left</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-string">&quot;R&quot;</span>)<br>        &#123;<br>            cin &gt;&gt; x ;<br>            <span class="hljs-built_in">add_most_right</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-string">&quot;D&quot;</span>)    <span class="hljs-comment">//因为是删除第k个插入的点，它对应的下标是k+1</span><br>        &#123; <br>            cin &gt;&gt; k;<br>            <span class="hljs-built_in">remove</span>(k<span class="hljs-number">+1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            cin &gt;&gt; k &gt;&gt; x;<br>            <span class="hljs-built_in">add_left</span>(k<span class="hljs-number">+1</span>, x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cin &gt;&gt; k &gt;&gt; x;<br>            <span class="hljs-built_in">add_right</span>(k<span class="hljs-number">+1</span>, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>; i = r[i] )<br>        cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>e = [<span class="hljs-number">0</span>] * N<br>l = [<span class="hljs-number">0</span>] * N<br>r = [<span class="hljs-number">0</span>] * N<br>idx = <span class="hljs-number">2</span><br>l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">k</span>):<br>    l[r[k]] = l[k]<br>    r[l[k]] = r[k]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">k, x</span>):     <span class="hljs-comment"># 在k号结点右边插入</span><br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = x<br>    r[idx] = r[k]<br>    l[idx] = k<br>    r[k] = idx<br>    l[r[idx]] = idx<br>    idx += <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        li = <span class="hljs-built_in">input</span>().split()<br>        <span class="hljs-keyword">if</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>            x = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>])<br>            insert(<span class="hljs-number">0</span>, x)<br>        <span class="hljs-keyword">elif</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;R&#x27;</span>:<br>            x = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>])<br>            insert(l[<span class="hljs-number">1</span>], x)<br>        <span class="hljs-keyword">elif</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;D&#x27;</span>:<br>            k = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>])<br>            delete(k+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">elif</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;IL&#x27;</span>:<br>            k, x = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(li[<span class="hljs-number">2</span>])<br>            insert(l[k+<span class="hljs-number">1</span>], x)<br>        <span class="hljs-keyword">else</span>:<br>            k, x = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(li[<span class="hljs-number">2</span>])<br>            insert(k+<span class="hljs-number">1</span>, x)<br>    res = []<br>    i = r[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">while</span> i != <span class="hljs-number">1</span>:<br>        x = <span class="hljs-built_in">int</span>(e[i])<br>        res.append(x)<br>        i = r[i]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, res)))<br></code></pre></td></tr></table></figure>



<ul>
<li>易错点：<ul>
<li>idx从2开始，因为0作为头结点，1作为尾结点了</li>
<li>因为idx从2开始，所以第k个插入的数对应的下标应该是k+1</li>
<li>因为是双链表，只用写一种插入函数（右插），那么左插就是在指定元素的左边那个元素进行右插</li>
</ul>
</li>
</ul>
<h3 id="2、栈、队列"><a href="#2、栈、队列" class="headerlink" title="2、栈、队列"></a>2、栈、队列</h3><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; num;   <span class="hljs-comment">//存数字</span><br>stack&lt;<span class="hljs-type">char</span>&gt; op;   <span class="hljs-comment">//存运算符</span><br><br><span class="hljs-comment">//优先级列表</span><br>unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; pr&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br><span class="hljs-comment">//一次运算操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> r  = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> c = op.<span class="hljs-built_in">top</span>();<br>    op.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> b = num.<span class="hljs-built_in">top</span>();<br>    num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a = num.<span class="hljs-built_in">top</span>();<br>    num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        r = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        r = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;*&#x27;</span>)<br>        r = a * b;<br>    <span class="hljs-keyword">else</span> <br>        r = a / b;<br>    num.<span class="hljs-built_in">push</span>(r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-comment">//遍历表达式，分三种情况</span><br>    <span class="hljs-comment">//1、数字</span><br>    <span class="hljs-comment">//2、左括号</span><br>    <span class="hljs-comment">//3、右括号</span><br>    <span class="hljs-comment">//4、算术运算符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))<br>        &#123;<br>            <span class="hljs-type">int</span> j = i, x = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//&amp;&amp;左右也是有先后顺序的（先左后右）， 所以我们要将j &lt; s.size()写在左边</span><br>            <span class="hljs-keyword">while</span>(j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[j]))<br>            &#123;<br>                x = x*<span class="hljs-number">10</span> + s[j++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            num.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-comment">//因为过了这个循环后i还要加一的</span><br>            i = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        &#123;<br>            op.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)<br>                <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//要将op.size()&gt;0写在左边</span><br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; pr[op.<span class="hljs-built_in">top</span>()] &gt;= pr[s[i]])<br>                <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">eval</span>();<br>    cout &lt;&lt; num.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&quot;(&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;/&quot;</span>: <span class="hljs-number">2</span>&#125;<br>num = []<br>op = []<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eval</span>():<br>    x1 = num.pop()<br>    x2 = num.pop()<br>    operator = op.pop()<br>    x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> operator == <span class="hljs-string">&quot;+&quot;</span>:<br>        x = x1 + x2<br>    <span class="hljs-keyword">elif</span> operator == <span class="hljs-string">&quot;-&quot;</span>:<br>        x = x2 - x1<br>    <span class="hljs-keyword">elif</span> operator == <span class="hljs-string">&quot;*&quot;</span>:<br>        x = x1 * x2<br>    <span class="hljs-keyword">else</span>:<br>        x = <span class="hljs-built_in">int</span>(x2 / x1)<br>    num.append(x)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = <span class="hljs-built_in">input</span>()<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(s):<br>        c = s[i]<br>        <span class="hljs-keyword">if</span> c.isdigit():<br>            x = <span class="hljs-number">0</span><br>            j = i<br>            <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[j].isdigit():<br>                x = x * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(s[j])<br>                j += <span class="hljs-number">1</span><br>            num.append(x)<br>            i = j - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&quot;(&quot;</span>:<br>            op.append(c)<br>        <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&quot;)&quot;</span>:<br>            <span class="hljs-keyword">while</span> op[-<span class="hljs-number">1</span>] != <span class="hljs-string">&quot;(&quot;</span>:<br>                <span class="hljs-built_in">eval</span>()<br>            op.pop()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">len</span>(op))<span class="hljs-keyword">and</span>(dic[c] &lt;= dic[op[-<span class="hljs-number">1</span>]]):  <span class="hljs-comment"># 判断条件的顺序不可换，当op为空时会出错</span><br>                <span class="hljs-built_in">eval</span>()<br>            op.append(c)<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(op):<br>        <span class="hljs-built_in">eval</span>()<br>    <span class="hljs-built_in">print</span>(num[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>



<ul>
<li>易错点<ul>
<li>除、减运算与操作数提出的顺序有关，要先提出除数，再提出被除数</li>
</ul>
</li>
</ul>
<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><ul>
<li>原型：找出数组某个元素左侧第一个比它小的元素</li>
<li>暴力算法时间复杂度为n^2, 用单调栈可降至n</li>
<li>单调栈中的元素是单调递增或递减的，每次入栈之前判断栈顶元素与入栈元素的大小关系，若栈顶元素更大，则栈顶元素出栈，再将入栈元素入栈</li>
<li><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88.png" srcset="/img/loading.gif" lazyload alt="单调栈"></li>
</ul>
<p>也就是插入B的时候会排除A，此时插入C，分两种情况：C大于B，则返回结果是B；C小于B，则排除B，返回结果是最左边的点。可见无论哪种情况均和A无关，所以可以排除A</p>
<ul>
<li>思路：先想暴力算法，看看有没有可以不要的元素，删去后看看有没有单调性，若有，则可以优化</li>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个长度为 <span class="hljs-built_in">N</span>的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">N</span>，表示数列长度。<br><br>第二行包含 <span class="hljs-built_in">N</span>个整数，表示整数数列。<br><br>输出格式<br>共一行，包含 <span class="hljs-built_in">N</span>个整数，其中第 i个数表示第 i个数的左边第一个比它小的数，如果不存在则输出 −<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> M, idx, stack[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; M;<br>    <span class="hljs-keyword">while</span>(M--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">while</span>(idx &amp;&amp; stack[idx] &gt;= x)<br>            idx--;<br>        <span class="hljs-keyword">if</span>(idx)<br>            cout &lt;&lt; stack[idx] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        stack[++idx] = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>)<br>a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>s = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[-<span class="hljs-number">1</span>] &gt;= a[i]:<br>        s.pop()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-built_in">print</span>(s[-<span class="hljs-number">1</span>], end = <span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-1&quot;</span>, end = <span class="hljs-string">&quot; &quot;</span>)<br>    s.append(a[i])<br>    <br></code></pre></td></tr></table></figure>







<h4 id="单调队列-滑动窗口"><a href="#单调队列-滑动窗口" class="headerlink" title="单调队列(滑动窗口)"></a>单调队列(滑动窗口)</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定一个大小为 n≤10^6的数组。<br>有一个大小为 k的滑动窗口，它从数组的最左边移动到最右边。<br>你只能在窗口中看到 k个数字。<br>每次滑动窗口向右移动一个位置。<br><br>以下是一个例子：该数组为 [1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 3 6 7]，k为 3。<br><br>窗口位置	            最小值	最大值<br>[1 3 <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span> 5 3 6 7	     <span class="hljs-string">-1</span>	  3<br>1 [3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span>] 5 3 6 7	     <span class="hljs-string">-3</span>	  3<br>1 3 [<span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5] 3 6 7	     <span class="hljs-string">-3</span>	  5<br>1 3 <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span> 5 3] 6 7	     <span class="hljs-string">-3</span>	  5<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> [5 3 6] 7	      3	  6<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 [3 6 7]	      3	  7<br>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。<br><br>输入格式<br>输入包含两行。<br>第一行包含两个整数 n和 k，分别代表数组长度和滑动窗口的长度。<br>第二行有 n个整数，代表数组的具体数值。<br>同行数据之间用空格隔开。<br>输出格式<br>输出包含两个。<br>第一行输出，从左至右，每个位置滑动窗口中的最小值。<br>第二行输出，从左至右，每个位置滑动窗口中的最大值。<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-comment">//a存输入队列，q存单调队列的下标</span><br><span class="hljs-comment">//hh&gt;tt之时队列为空</span><br><span class="hljs-type">int</span> a[N], q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; a[i];<br>        <br>    <span class="hljs-comment">//先求最小，要求单调队列递增，q队首数据对应元素即为最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-comment">//q队列不为空并且队头超出窗口范围，弹出队头元素</span><br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>)<br>            hh++;<br>        <span class="hljs-comment">//q不为空且队尾元素大于要入队元素，队尾元素出队</span><br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])<br>            tt--;<br>        <span class="hljs-comment">//元素入队</span><br>        q[++tt] = i;<br>        <br>        <span class="hljs-comment">//当窗口内有k个元素时才输出队首元素（此窗口的最小值）</span><br>        <span class="hljs-keyword">if</span>(i &gt;= k<span class="hljs-number">-1</span>)<br>            cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">//一定要重新初始化q数组</span><br>    hh = <span class="hljs-number">0</span>;<br>    tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>)<br>            hh++;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])<br>            tt--;<br>        q[++tt] = i;<br>        <span class="hljs-keyword">if</span>(i &gt;= k<span class="hljs-number">-1</span>)<br>            cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><p>为啥不在原地处理单调队列，还要弄个q来储存下标？</p>
<p>  因为原地处理的话判断不了队头和队尾元素之间是否满足刚好有k个元素</p>
</li>
</ul>
<h3 id="3、KMP"><a href="#3、KMP" class="headerlink" title="3、KMP"></a>3、KMP</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43869106/article/details/128753527">图解KMP算法，带你彻底吃透KMP-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">1000010</span>;<br><span class="hljs-comment">//p为模式串, s为主串</span><br>string s, p;<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; p;<br>    cin &gt;&gt; m;<br>    cin &gt;&gt; s;<br>    <br>    <span class="hljs-comment">//ne为前缀和数组</span><br>    <span class="hljs-type">int</span> ne[n], j = <span class="hljs-number">0</span>;<br>    ne[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//先得到next数组, i从1开始,j从0开始</span><br>    <span class="hljs-comment">//i指针指向的是后缀末尾，j指针指向的是前缀末尾</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; p.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j])   <span class="hljs-comment">//前后缀不相同，去找j前一位的最长相等前后缀</span><br>            j = ne[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(p[i] == p[j])          <span class="hljs-comment">//前后缀相同，j指针后移</span><br>            j++;<br>        ne[i] = j;                 <span class="hljs-comment">//更新ne数组</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//匹配 , j和i均从0开始</span><br>    <span class="hljs-comment">//主串一直往后走, 模板串会更具ne数组回溯</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[j] != s[i]) <br>            j = ne[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(p[j] == s[i])<br>            j++;<br>        <span class="hljs-keyword">if</span>(j == p.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            cout &lt;&lt; i-j<span class="hljs-number">+1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            j = ne[j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4、Trie"><a href="#4、Trie" class="headerlink" title="4、Trie"></a>4、Trie</h3><h4 id="4-1模板"><a href="#4-1模板" class="headerlink" title="4.1模板"></a>4.1模板</h4><ul>
<li>储存字符串的集合，以便实现快速&#x3D;&#x3D;储存&#x3D;&#x3D;和&#x3D;&#x3D;查找&#x3D;&#x3D;</li>
<li>原理：只用遍历一遍字符串，时间复杂度为O(M),M为字符串总长度</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/Trie.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>题目：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">维护一个字符串集合，支持两种操作：<br><span class="hljs-selector-tag">I</span> <span class="hljs-attribute">x</span> 向集合中插入一个字符串 <span class="hljs-attribute">x</span>；<br><span class="hljs-selector-tag">Q</span> <span class="hljs-attribute">x</span> 询问一个字符串在集合中出现了多少次。<br>共有N个操作，所有输入的字符串总长度不超过 <span class="hljs-number">10</span>^<span class="hljs-number">5</span>,字符串仅包含小写英文字母。<br><br>输入格式<br>第一行包含整数 N，表示操作数。<br>接下来 N行，每行包含一个操作指令，指令为 <span class="hljs-selector-tag">I</span> <span class="hljs-attribute">x</span> 或 <span class="hljs-selector-tag">Q</span> <span class="hljs-attribute">x</span> 中的一种。<br><br>输出格式<br>对于每个询问指令 <span class="hljs-selector-tag">Q</span> <span class="hljs-attribute">x</span>，都要输出一个整数作为结果，表示 <span class="hljs-attribute">x</span>在集合中出现的次数。<br>每个结果占一行。<br></code></pre></td></tr></table></figure>

<ul>
<li><p>思路：</p>
<ul>
<li>idx存储当前用到哪个结点，son是一个26*N的矩阵，用于存储Trie，cnt[i]用于记录以i下标结束的字符串的个数</li>
<li>插入时，每次遍历从根结点p&#x3D;0开始，如果没有路，即son[p][x]&#x3D;0,则创建一个结点idx++，然后p往下走p&#x3D;son[p][x]</li>
<li>一直走到最后的p就是该字符串结束对应的idx，使其的cnt++</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> idx, s[N][<span class="hljs-number">26</span>], cnt[N]; <span class="hljs-comment">//s用于储存树，cnt用于记录以该下标结束的字符串的数量，idx用于记录当前用到了那个结点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; a[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = a[i] - <span class="hljs-string">&#x27;a&#x27;</span>;      <span class="hljs-comment">//找到字母在0~25对应的下标</span><br>        <span class="hljs-keyword">if</span>(!s[p][u]) s[p][u] = ++idx;<br>        p = s[p][u];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; a[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = a[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!s[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> p = s[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">char</span> c;<br>        cin &gt;&gt; c;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            string a;<br>            cin &gt;&gt; a;<br>            <span class="hljs-built_in">insert</span>(a);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            string a;<br>            cin &gt;&gt; a;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(a) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>son = [[<span class="hljs-number">0</span>]*<span class="hljs-number">26</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>cnt = [<span class="hljs-number">0</span>] * N<br>idx = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    p = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        x = <span class="hljs-built_in">ord</span>(s[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>        <span class="hljs-keyword">if</span> son[p][x] == <span class="hljs-number">0</span>:<br>            idx += <span class="hljs-number">1</span> <br>            son[p][x] = idx<br>        p = son[p][x]<br>    cnt[p] += <span class="hljs-number">1</span> <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">s</span>):<br>    p = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        x = <span class="hljs-built_in">ord</span>(s[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>        <span class="hljs-keyword">if</span> son[p][x] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = son[p][x]<br>    <span class="hljs-keyword">return</span> cnt[p]<br>        <br>        <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span> <br>        li = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;I&quot;</span>:<br>            insert(li[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(query(li[<span class="hljs-number">1</span>]))<br>        <br></code></pre></td></tr></table></figure>



<h4 id="4-2最大异或对"><a href="#4-2最大异或对" class="headerlink" title="4.2最大异或对"></a>4.2最大异或对</h4><ul>
<li><p>告诉我们Trie不仅可以存字符串，还可以存二进制数</p>
</li>
<li><p>用Trie储存二进制数字，从最高位开始储存（因为我们要保证贪心算法的可行性，从高位存储的话，越高位能够找到异或对，则异或结果越大）</p>
</li>
<li><p>采用贪心思想：每遍历一位都要去找相异的，0找1，1找0，如果实在没有相异的才往下走，有相异的就去到相异的那边</p>
</li>
<li><p>这样遍历完这个数字的所有二进制位就可以找到它的最大异或数，时间复杂度为O(logn)， 找完所有数字的最大异或数则要O(n*logn)的时间复杂度</p>
</li>
<li><p>原理过程：</p>
</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>题目：</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">在给定的 <span class="hljs-built_in">N</span>个整数 <span class="hljs-symbol">A1</span>，<span class="hljs-symbol">A2</span>……AN中选出两个进行 <span class="hljs-built_in">xor</span>（异或）运算，得到的结果最大是多少？<br><br>输入格式<br>第一行输入一个整数 <span class="hljs-built_in">N</span>。<br>第二行输入 <span class="hljs-built_in">N</span>个整数 <span class="hljs-symbol">A1</span>～AN。<br><br>输出格式<br>输出一个整数表示答案。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">N</span>≤<span class="hljs-number">105</span>, <span class="hljs-number">0</span>≤Ai&lt;<span class="hljs-number">231</span><br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">31</span>*N;<br><span class="hljs-type">int</span> son[M][<span class="hljs-number">2</span>], a[N], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> u = a &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<br>        p = son[p][u];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> u = a &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[p][!u])<br>        &#123;<br>            p = son[p][!u];<br>            res = res*<span class="hljs-number">2</span> + !u;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            p = son[p][u];<br>            res = res * <span class="hljs-number">2</span> + u;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, res;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">insert</span>(a[i]);<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">query</span>(a[i]);<br>        res = <span class="hljs-built_in">max</span>(res, a[i] ^ t);<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>son = [[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N*<span class="hljs-number">31</span>)]  <span class="hljs-comment"># N个整数，每个整数最长31位</span><br>idx = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    i = <span class="hljs-number">30</span><br>    p = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>:<br>        u = x &gt;&gt; i &amp; <span class="hljs-number">1</span> <br>        <span class="hljs-keyword">if</span> son[p][u] == <span class="hljs-number">0</span>:<br>            idx += <span class="hljs-number">1</span> <br>            son[p][u] = idx<br>        p = son[p][u]<br>        i -= <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">x</span>):<br>    res = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">30</span><br>    p = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>:<br>        u = x &gt;&gt; i &amp; <span class="hljs-number">1</span><br>        w = u ^ <span class="hljs-number">1</span>         <span class="hljs-comment"># python不可以用!u</span><br>        <span class="hljs-keyword">if</span> son[p][w]:<br>            p = son[p][w]<br>            res = res * <span class="hljs-number">2</span> + w<br>        <span class="hljs-keyword">else</span>:<br>            p = son[p][u]<br>            res = res * <span class="hljs-number">2</span> + u<br>        i -= <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">return</span> res^x<br>        <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    li = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        insert(li[i])<br>    ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        ret = <span class="hljs-built_in">max</span>(ret, query(li[i]))<br>    <span class="hljs-built_in">print</span>(ret)<br></code></pre></td></tr></table></figure>





<h3 id="5、并查集"><a href="#5、并查集" class="headerlink" title="5、并查集"></a>5、并查集</h3><h4 id="5-1模板"><a href="#5-1模板" class="headerlink" title="5.1模板"></a>5.1模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>   <span class="hljs-comment">//初始化p数组，让每个结点的父节点一开始都指向自己</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++)<br>        p[i] = i;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>  <span class="hljs-comment">// 包含状态压缩，也就是让遍历过的结点均指向他的根结点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);  <span class="hljs-comment">// 状态压缩</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b))<br>        p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">char</span> op;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;M&#x27;</span>)<br>        &#123;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            <span class="hljs-built_in">merge</span>(a, b);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b))<br>                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> <br>                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>p = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x != p[x]:<br>        p[x] = find(p[x])<br>    <span class="hljs-keyword">return</span> p[x]<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        p[i] = i<br>    <span class="hljs-keyword">while</span> m:<br>        m -= <span class="hljs-number">1</span> <br>        li = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().split())<br>        a,b = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(li[<span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">if</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;M&#x27;</span>:<br>            p[find(a)] = find(b)<br>        <span class="hljs-keyword">elif</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>            <span class="hljs-keyword">if</span> find(a) == find(b):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure>



<h4 id="5-2食物链"><a href="#5-2食物链" class="headerlink" title="5.2食物链"></a>5.2食物链</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">动物王国中有三类动物 <span class="hljs-variable">A</span><span class="hljs-operator">,</span><span class="hljs-variable">B</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span>，这三类动物的食物链构成了有趣的环形。<br><span class="hljs-variable">A</span>吃 <span class="hljs-variable">B</span>，<span class="hljs-variable">B</span>吃 <span class="hljs-built_in">C</span>，<span class="hljs-built_in">C</span>吃 <span class="hljs-variable">A</span>。<br><br>现有 <span class="hljs-built_in">N</span>个动物，以 <span class="hljs-number">1</span>∼<span class="hljs-built_in">N</span>编号。<br>每个动物都是 <span class="hljs-variable">A</span><span class="hljs-operator">,</span><span class="hljs-variable">B</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span>中的一种，但是我们并不知道它到底是哪一种。<br><br>有人用两种说法对这 <span class="hljs-built_in">N</span>个动物所构成的食物链关系进行描述：<br>第一种说法是 <span class="hljs-number">1</span> <span class="hljs-variable">X</span> <span class="hljs-variable">Y</span>，表示 <span class="hljs-variable">X</span>和 <span class="hljs-variable">Y</span>是同类。<br>第二种说法是 <span class="hljs-number">2</span> <span class="hljs-variable">X</span> <span class="hljs-variable">Y</span>，表示 <span class="hljs-variable">X</span>吃 <span class="hljs-variable">Y</span>。<br>此人对 <span class="hljs-built_in">N</span>个动物，用上述两种说法，一句接一句地说出 <span class="hljs-built_in">K</span>句话，这 <span class="hljs-built_in">K</span>句话有的是真的，有的是假的。<br><br>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>当前的话与前面的某些真的话冲突，就是假话；<br>当前的话中 <span class="hljs-variable">X</span>或 <span class="hljs-variable">Y</span>比 <span class="hljs-built_in">N</span>大，就是假话；<br>当前的话表示 <span class="hljs-variable">X</span>吃 <span class="hljs-variable">X</span>，就是假话。<br>你的任务是根据给定的 <span class="hljs-built_in">N</span>和 <span class="hljs-built_in">K</span>句话，输出假话的总数。<br><br>输入格式<br>第一行是两个整数 <span class="hljs-built_in">N</span>和 <span class="hljs-built_in">K</span>，以一个空格分隔。<br>以下 <span class="hljs-built_in">K</span>行每行是三个正整数 <span class="hljs-built_in">D</span>，<span class="hljs-variable">X</span>，<span class="hljs-variable">Y</span>，两数之间用一个空格隔开，其中 <span class="hljs-built_in">D</span>表示说法的种类。<br>若 <span class="hljs-built_in">D</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>，则表示 <span class="hljs-variable">X</span>和 <span class="hljs-variable">Y</span>是同类。<br>若 <span class="hljs-built_in">D</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>，则表示 <span class="hljs-variable">X</span>吃 <span class="hljs-variable">Y</span>。<br><br>输出格式<br>只有一个整数，表示假话的数目。<br></code></pre></td></tr></table></figure>



<ul>
<li>思路：</li>
</ul>
<p>把动物之间的关系用并查集储存，用它们之间的距离来分，相距0为同类，a与b相距1为a吃b，a与b相距2为b吃a，再把它们之间的距离全都体现为各自到根结点的距离，到根结点的距离之差即为它们之间相距的距离。</p>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E9%A3%9F%E7%89%A9%E9%93%BE.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>思路：</p>
<ul>
<li>用结点x到<strong>根节点</strong>的距离来进行分类：若dis[x]%3&#x3D;0，则x与根节点是同类；若dis[x]%3&#x3D;1,则x可以吃根节点；若dis[x]%3&#x3D;2,则x可以被根节点吃</li>
<li>维护一个额外的距离数组d[x]，存储x到<strong>父节点</strong>的距离。我们在进行find操作的时候会进行压缩，也就是说find操作过后d[x]就变为了x到根结点的距离了（此时x的根节点就是它的父节点）。此时，讨论结点a，b的关系（均经过find操作），就是讨论a，b结点与根节点的关系：若d[a]%3&#x3D;d[b]%3,则a，b是同类；若(d[a] - d[b] - 1) % 3 &#x3D; 0,则a能吃b</li>
<li>在讨论a，b的关系的时候，要分两种情况：a，b所属类别之间的关系尚未定义，则给出定义；a，b类别之间的关系给定，则判断是否正确</li>
<li>find函数</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(x != p[x])<br>    &#123;<br>        <span class="hljs-type">int</span> temp = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>​			find(p[x])就是找到x的祖宗结点，用temp存储一下，此时的结点关系是x连着p[x]，p[x]经过压缩后连着祖			宗结点，d[p[x]]也是p[x]到祖宗结点的距离，那么x到祖宗结点的距离就是d[x]+d[p[x]]，更新完d[x]后，才			可以更新x的父节点，使x连向祖宗结点</p>
<p>​			如果直接让p[x]&#x3D;find(p[x])的话，d[p[x]]就不是x的父节点到祖宗结点的距离了，而是祖宗结点自己到自己			的距离</p>
<p>​										                              x —&gt;x的父节点 —&gt;x的祖宗结点</p>
<p>​                                                                          d[x]                  d[p[x]]</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>, K = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> p[N] , d[N];  <span class="hljs-comment">//d数组记录当前下标的动物到它父节点的距离</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>    <span class="hljs-comment">//在find的过程不断压缩路径</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(p[x]); <br>        d[x] += d[p[x]];<br>        p[x] = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k, cnt = <span class="hljs-number">0</span>;   <span class="hljs-comment">//cnt用于记录错误的条数</span><br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        p[i] = i;<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        <span class="hljs-type">int</span> t, a, b;<br>        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(a &gt; n || b &gt; n)    <span class="hljs-comment">//越界直接错误</span><br>        &#123;<br>            cnt ++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-type">int</span> pa = <span class="hljs-built_in">find</span>(a), pb = <span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(pa == pb &amp;&amp; (d[a] - d[b]) % <span class="hljs-number">3</span>)  <span class="hljs-comment">//实际上是(d[a]%3) != (d[b]%3) 就说明a、b不算同类</span><br>                    cnt ++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pa != pb)   <span class="hljs-comment">//不在同一棵树上，说明a和b之间还未确定关系，为它们确定关系为同类</span><br>                &#123;<br>                    p[pa] = pb;<br>                    d[pa] = d[b] - d[a];  <span class="hljs-comment">//画图理解</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(pa == pb &amp;&amp; (d[a] - d[b] - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>) <span class="hljs-comment">//实际上是((d[a]-d[b])%3) != 1 就说明a不能吃b</span><br>                    cnt ++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pa != pb)<br>                &#123;<br>                    p[pa] = pb;<br>                    d[pa] = d[b] - d[a] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">5e4</span> + <span class="hljs-number">5</span>)<br>p = [<span class="hljs-number">0</span>] * N<br>d = [<span class="hljs-number">0</span>] * N<br><br>def <span class="hljs-built_in">find</span>(x):<br>    <span class="hljs-keyword">if</span> x != p[x]:<br>        t = <span class="hljs-built_in">find</span>(p[x])<br>        d[x] += d[p[x]]<br>        p[x] = t<br>    <span class="hljs-keyword">return</span> p[x]<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>, <span class="hljs-built_in">input</span>().<span class="hljs-built_in">split</span>())<br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        p[i] = i <br>    <span class="hljs-keyword">while</span> m:<br>        m -= <span class="hljs-number">1</span><br>        op, a, b = <span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>, <span class="hljs-built_in">input</span>().<span class="hljs-built_in">split</span>())<br>        <span class="hljs-keyword">if</span> a &gt; n <span class="hljs-keyword">or</span> b &gt; n:<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            pa, pb = <span class="hljs-built_in">find</span>(a), <span class="hljs-built_in">find</span>(b)<br>            <span class="hljs-keyword">if</span> op == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> pa == pb <span class="hljs-built_in">and</span> (d[a] - d[b]) % <span class="hljs-number">3</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                elif pa != pb:<br>                    p[pa] = pb<br>                    d[pa] = d[b] - d[a]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> pa == pb <span class="hljs-built_in">and</span> (d[a] - d[b] - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                elif pa != pb:<br>                    p[pa] = pb<br>                    d[pa] = d[b] - d[a] + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(cnt)<br></code></pre></td></tr></table></figure>



<h4 id="5-3、连通块中点的数量"><a href="#5-3、连通块中点的数量" class="headerlink" title="5.3、连通块中点的数量"></a>5.3、连通块中点的数量</h4><p>通过额外维护一个size数组来记录一个集合中的元素个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>p = [<span class="hljs-number">0</span>] * N<br>size = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x != p[x]:<br>        p[x] = find(p[x])<br>    <span class="hljs-keyword">return</span> p[x]<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        p[i] = i<br>        size[i] = <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">while</span> m:<br>        m -= <span class="hljs-number">1</span> <br>        li = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;C&quot;</span>:<br>            a, b = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(li[<span class="hljs-number">2</span>])<br>            pa, pb = find(a), find(b)<br>            <span class="hljs-keyword">if</span> pa != pb:<br>                size[pa] += size[pb]<br>                p[pb] = pa<br>        <span class="hljs-keyword">elif</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;Q1&quot;</span>:<br>            a, b = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(li[<span class="hljs-number">2</span>])<br>            <span class="hljs-keyword">if</span> find(a) == find(b):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            a = <span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>])<br>            <span class="hljs-built_in">print</span>(size[find(a)])<br></code></pre></td></tr></table></figure>





<h3 id="6、堆"><a href="#6、堆" class="headerlink" title="6、堆"></a>6、堆</h3><p>手写堆：</p>
<p>插入一个数 : heap[++size] &#x3D; x; up(size)</p>
<p>求最小值: heap[1]</p>
<p>删除最小值: heap[1] &#x3D; heap[size]; size- -; down(1)</p>
<p>删除任意一个数: heap[k] &#x3D; heap[size]; size- -; down(k); up(k);    </p>
<p>修改任意一个数 : heap[k] &#x3D; x; down(k); up(k)</p>
<h4 id="6-1、堆排序"><a href="#6-1、堆排序" class="headerlink" title="6.1、堆排序"></a>6.1、堆排序</h4><ul>
<li>细节说明：<ul>
<li>先创建再维护，可以将时间复杂度从O(nlogn) 降低到O(n)</li>
<li>维护时从n&#x2F;2开始down，是为了从倒数第二层有叶节点的结点开始down</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> heap[N], s;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = k;    <span class="hljs-comment">//t储存三个数中最小的数的下标</span><br>    <span class="hljs-keyword">if</span>(k*<span class="hljs-number">2</span> &lt;= s &amp;&amp; heap[<span class="hljs-number">2</span>*k] &lt; heap[t])  t = <span class="hljs-number">2</span>*k;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*k<span class="hljs-number">+1</span> &lt;= s &amp;&amp; heap[<span class="hljs-number">2</span>*k<span class="hljs-number">+1</span>] &lt; heap[t]) t = <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(t != k)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(heap[t], heap[k]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//void up(int k)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(k / <span class="hljs-number">2</span> &amp;&amp; heap[k / <span class="hljs-number">2</span>] &lt; heap[k])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(heap[k/<span class="hljs-number">2</span>], heap[k]);<br>        k /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//先创建堆再维护，降低时间复杂度为O(n)</span><br>        cin &gt;&gt; heap[i];<br>    s = n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) <span class="hljs-comment">//从倒数第二层开始修正</span><br>    &#123;<br>        <span class="hljs-built_in">down</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        cout &lt;&lt; heap[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        heap[<span class="hljs-number">1</span>] = heap[s--];<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>heap = [<span class="hljs-number">0</span>] * N<br><span class="hljs-built_in">size</span> = <span class="hljs-number">0</span><br><br>def <span class="hljs-title function_">down</span>(x):<br>    global <span class="hljs-built_in">size</span><br>    k = x<br>    <span class="hljs-keyword">if</span> x * <span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">size</span> and heap[x*<span class="hljs-number">2</span>] &lt; heap[k]:<br>        k = x * <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">size</span> and heap[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] &lt; heap[k]:<br>        k = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">if</span> x != k:<br>        heap[k], heap[x] = heap[x], heap[k]<br>        <span class="hljs-title function_">down</span>(k)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>, <span class="hljs-title function_">input</span>().<span class="hljs-property">split</span>())<br>    <span class="hljs-built_in">size</span> = n<br>    heap[<span class="hljs-number">1</span>: n + <span class="hljs-number">1</span>] = <span class="hljs-title function_">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>, <span class="hljs-title function_">input</span>().<span class="hljs-property">split</span>()))<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-title function_">range</span>(<span class="hljs-built_in">int</span>(n / <span class="hljs-number">2</span>), <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):<br>        <span class="hljs-title function_">down</span>(i)<br>    <span class="hljs-keyword">while</span> m:<br>        m -= <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(heap[<span class="hljs-number">1</span>], end = <span class="hljs-string">&quot; &quot;</span>)<br>        heap[<span class="hljs-number">1</span>] = heap[<span class="hljs-built_in">size</span>]<br>        <span class="hljs-built_in">size</span> -= <span class="hljs-number">1</span><br>        <span class="hljs-title function_">down</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>





<h3 id="7、哈希表"><a href="#7、哈希表" class="headerlink" title="7、哈希表"></a>7、哈希表</h3><h4 id="7-1-模板"><a href="#7-1-模板" class="headerlink" title="7.1 模板"></a>7.1 模板</h4><ul>
<li>拉链法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100003</span>;   <span class="hljs-comment">//拉链法一般都是将N控制在大于数组长度的最小质数</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx; <span class="hljs-comment">//e数组用于存储数据，idx指向e数组的可用位置，ne数组用于存储指针</span><br><span class="hljs-comment">//h数组用于储存每个位置的头指针，相当于每个位置都有一条链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//x如果是负数的话，x%N也是负数，所以我们要先x%N减小x，再+N，最后再%N</span><br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span>(e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)  <span class="hljs-comment">//头结点起始每个都为空（=-1）</span><br>        h[i] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">char</span> op;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; op &gt;&gt; x;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            <span class="hljs-built_in">insert</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x))<br>                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> <br>                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>)<br>e = [<span class="hljs-number">0</span>] * N<br>ne = [<span class="hljs-number">0</span>] * N<br>h = [-<span class="hljs-number">1</span>] * N<br>idx = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    k = (x % N + N) % N <br>    e[idx] = x<br>    ne[idx] = h[k]<br>    h[k] = idx<br>    idx += <span class="hljs-number">1</span> <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">x</span>):<br>    k = (x % N + N) % N<br>    i = h[k]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> e[i] == x:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        i = ne[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        h[i] = -<span class="hljs-number">1</span><br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span> <br>        li = <span class="hljs-built_in">input</span>().split()<br>        <span class="hljs-keyword">if</span> li[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>:<br>            insert(<span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]))<br>        <span class="hljs-keyword">else</span>:<br>            res = query(<span class="hljs-built_in">int</span>(li[<span class="hljs-number">1</span>]))<br>            <span class="hljs-keyword">if</span> res == <span class="hljs-literal">True</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure>



<ul>
<li>开放寻址法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>;  <span class="hljs-comment">//将N控制在大于数组长度两倍的最小质数</span><br><span class="hljs-type">int</span> h[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)<br>    &#123;<br>        k ++;<br>        <span class="hljs-keyword">if</span>(k == N)<br>            k = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        h[i] = null;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">char</span> op;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; op &gt;&gt; x;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;I&#x27;</span>)<br>        &#123;<br>            h[<span class="hljs-built_in">find</span>(x)] = x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">if</span>(h[<span class="hljs-built_in">find</span>(x)] == null)<br>                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> <br>                cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="7-2字符串前缀哈希"><a href="#7-2字符串前缀哈希" class="headerlink" title="7.2字符串前缀哈希"></a>7.2字符串前缀哈希</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm">给定一个长度为 n的字符串，再给定 m个询问，每个询问包含四个整数 l1,<span class="hljs-built_in">r1</span>,l2,<span class="hljs-built_in">r2</span>，请你判断 [l1,<span class="hljs-built_in">r1</span>]和 [l2,<span class="hljs-built_in">r2</span>]这两个区间所包的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。<br><br>输入格式<br>第一行包含整数 n和 m，表示字符串长度和询问次数。<br>第二行包含一个长度为 n的字符串，字符串中只包含大小写英文字母和数字。<br>接下来 m行，每行包含四个整数 l1,<span class="hljs-built_in">r1</span>,l2,<span class="hljs-built_in">r2</span>，表示一次询问所涉及的两个区间。<br><br>注意，字符串的位置从 <span class="hljs-number">1</span>开始编号。<br><br>输出格式<br>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。<br></code></pre></td></tr></table></figure>



<ul>
<li>原理<ul>
<li>用h数组储存字符串对应前缀的哈希值</li>
<li>如何确定哈希值<ul>
<li>将前缀字符串abc看作p进制的，(a*p^2 + b*p^1 + c*p^0) % Q</li>
<li>经验值：p一般取131、13331，Q一般取2^64</li>
<li>Hash(R~L) &#x3D; h[R] - h[L-1] * p^(R-L+1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL; <span class="hljs-comment">//2^64位</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, P = <span class="hljs-number">131</span>; <span class="hljs-comment">//经验值，一般不会冲突</span><br>string str;<br>ULL h[N], p[N];     <span class="hljs-comment">//h用于存哈希值， p用于存P的对应次方， 定义为ULL型的数组就可以不用mod2^64了</span><br><span class="hljs-comment">//h数组从下标1开始存数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin &gt;&gt; str;<br>    <br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        p[i] = P * p[i - <span class="hljs-number">1</span>];<br>        h[i] = P * h[i - <span class="hljs-number">1</span>] + str[i - <span class="hljs-number">1</span>];   <span class="hljs-comment">//str从0开始的 </span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l1, r1, l2, r2;<br>        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l1, r1) == <span class="hljs-built_in">get</span>(l2, r2))<br>            cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="三、搜索与图论"><a href="#三、搜索与图论" class="headerlink" title="三、搜索与图论"></a>三、搜索与图论</h2><h3 id="1、-DFS"><a href="#1、-DFS" class="headerlink" title="1、 DFS"></a>1、 DFS</h3><ul>
<li>实现基础：栈</li>
<li>空间复杂度：O(n)</li>
</ul>
<h4 id="1-1、排列数字（全排序）"><a href="#1-1、排列数字（全排序）" class="headerlink" title="1.1、排列数字（全排序）"></a>1.1、排列数字（全排序）</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个整数 n，将数字 1∼n排成一排，将会有很多种排列方法。<br>现在，请你按照字典序将所有的排列方法输出。<br><br>输入格式<br>共一行，包含一个整数 n。<br><br>输出格式<br>按字典序输出所有排列方案，每个方案占一行。<br><br>数据范围<br>1≤n≤7<br>输入样例：<br>3<br>输出样例：<br>1<span class="hljs-number"> 2 </span>3<br>1<span class="hljs-number"> 3 </span>2<br>2<span class="hljs-number"> 1 </span>3<br>2<span class="hljs-number"> 3 </span>1<br>3<span class="hljs-number"> 1 </span>2<br>3<span class="hljs-number"> 2 </span>1<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> path[N], st[N];  <span class="hljs-comment">//path数组用于储存路径，st数组用于储存该数字是否访问过的标记</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>   <span class="hljs-comment">//k无实际意义，仅用于计数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(k == n)       <span class="hljs-comment">//说明已经到底了，可用输出path数组了</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st[i])    <span class="hljs-comment">//i未被访问</span><br>            &#123;<br>                path[k] = i;<br>                st[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">bfs</span>(k + <span class="hljs-number">1</span>);   <span class="hljs-comment">//继续访问下一层</span><br>                st[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//回溯，需要复原</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>)<br>path = [<span class="hljs-number">0</span>] * N<br>st = [<span class="hljs-literal">False</span>] * N<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-keyword">if</span> u == n:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-built_in">print</span>(path[i], end = <span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-keyword">return</span> <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> st[i] == <span class="hljs-literal">False</span>:<br>            path[u] = i<br>            st[i] = <span class="hljs-literal">True</span><br>            dfs(u + <span class="hljs-number">1</span>)<br>            st[i] = <span class="hljs-literal">False</span><br>        <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    dfs(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>



<h4 id="1-2、八皇后问题"><a href="#1-2、八皇后问题" class="headerlink" title="1.2、八皇后问题"></a>1.2、八皇后问题</h4><ul>
<li><p>思路</p>
<ul>
<li>和全排序一样，用DFS，一直向下找，有冲突就回溯（已知每一行只有一个皇后，则每一行放下一个之后就直接往后下走）</li>
<li>用三个数组来判断是否冲突</li>
<li>对角线的下标问题</li>
</ul>
<p>  <img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> g[N][N];   <span class="hljs-comment">//棋盘</span><br><span class="hljs-type">bool</span> col[N], dg[N], udg[N];  <span class="hljs-comment">//col判断该列是否有棋子，dg判断正对角线（有2n+1条）是否有棋子，udg判断反对角线是否有棋子</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>  <span class="hljs-comment">//k代表正在遍历第k行</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(k == n)     <span class="hljs-comment">//有结果了，输出</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>                cout &lt;&lt; g[i][j];<br>            cout &lt;&lt; endl;<br>        &#125;<br>            <br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)   <span class="hljs-comment">//行列均从下标0开始</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !dg[k + i] &amp;&amp; !udg[i - k + n])  <span class="hljs-comment">//g[k][i]可以放棋子</span><br>            &#123;<br>                g[k][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                col[i] = dg[k + i] = udg[i - k + n] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//对角线的下标问题如上图</span><br>                <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);        <span class="hljs-comment">//回溯，复原</span><br>                col[i] = dg[k + i] = udg[i - k + n] = <span class="hljs-literal">false</span>;<br>                g[k][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            g[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs perl">def dfs(u):<br>    <span class="hljs-keyword">if</span> u == n:<br>        <span class="hljs-keyword">for</span> i in range(n):<br>            <span class="hljs-keyword">for</span> j in range(n):<br>                <span class="hljs-keyword">print</span>(<span class="hljs-string">q[i]</span>[j], end = <span class="hljs-string">&quot; &quot;</span>)<br>            <span class="hljs-keyword">print</span>()<br>        <span class="hljs-keyword">print</span>()<br>        <span class="hljs-keyword">return</span> <br>    <span class="hljs-keyword">for</span> i in range(n):<br>        <span class="hljs-keyword">if</span> cor[i] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dg[i+u] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> udg[i-u+n] == <span class="hljs-number">0</span>:<br>            cor[i] = <span class="hljs-number">1</span> <br>            dg[i+u] = <span class="hljs-number">1</span> <br>            udg[i-u+n] = <span class="hljs-number">1</span><br>            <span class="hljs-string">q[u]</span>[i] = <span class="hljs-string">&#x27;Q&#x27;</span><br>            dfs(u+<span class="hljs-number">1</span>)<br>            cor[i] = <span class="hljs-number">0</span> <br>            dg[i+u] = <span class="hljs-number">0</span><br>            udg[i-u+n] = <span class="hljs-number">0</span><br>            <span class="hljs-string">q[u]</span>[i] = <span class="hljs-string">&#x27;.&#x27;</span><br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    N = <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>)<br>    cor = [<span class="hljs-number">0</span>]*N<br>    dg = [<span class="hljs-number">0</span>]*(<span class="hljs-number">2</span>*N)<br>    udg = [<span class="hljs-number">0</span>]*(<span class="hljs-number">2</span>*N)<br>    <span class="hljs-keyword">q</span> = [[<span class="hljs-string">&#x27;.&#x27;</span><span class="hljs-keyword">for</span> _ in range(N)] <span class="hljs-keyword">for</span> _ in range(N)]<br>    n = <span class="hljs-keyword">int</span>(input())<br>    dfs(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>





<h3 id="2、BFS"><a href="#2、BFS" class="headerlink" title="2、BFS"></a>2、BFS</h3><h4 id="2-1、迷宫问题"><a href="#2-1、迷宫问题" class="headerlink" title="2.1、迷宫问题"></a>2.1、迷宫问题</h4><p>&#x3D;&#x3D;用BFS求解最短路问题要求每条边的权值是一样的&#x3D;&#x3D;</p>
<ul>
<li>题目</li>
</ul>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个 n×m的二维整数数组，用来表示一个迷宫，数组中只包含 0或 1，其中 0表示可以走的路，1表示不可通过的墙壁。<br>最初，有一个人位于左上角 (1,1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角(n,m)处，至少需要移动多少次。<br>数据保证 (1,1)处和 (n,m)处的数字为 0，且一定至少存在一条通路。<br><br>输入格式<br>第一行包含两个整数 n和 m。<br>接下来 n行，每行包含 m个整数（0或 1），表示完整的二维数组迷宫。<br><br>输出格式<br>输出一个整数，表示从左上角移动至右下角的最少移动次数。<br><br>数据范围<br>1≤n,m≤100<br>输入样例：<br>5 5<br>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0<br>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 1 </span>0<br>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<br>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>0<br>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>0<br>输出样例：<br>8<br></code></pre></td></tr></table></figure>

<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E8%BF%B7%E5%AE%AB.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PLL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> d[N][N], g[N][N];  <span class="hljs-comment">//d储存每个点到起点的距离， g储存地图</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;PLL&gt; q;    <span class="hljs-comment">//队列的元素是对， 是坐标</span><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);  <span class="hljs-comment">//初始化队列</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) <br>            d[i][j] = <span class="hljs-number">-1</span>;       <span class="hljs-comment">//初始化距离数组</span><br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;  <span class="hljs-comment">//向量化数组，决定往哪走</span><br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())   <span class="hljs-comment">//队列不为空，就一直入队再出队</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">if</span>(t.first == n<span class="hljs-number">-1</span> &amp;&amp; t.second == m<span class="hljs-number">-1</span>)<br>        &#123;<br>            cout &lt;&lt; d[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)    <span class="hljs-comment">//决定t点四个方向哪个方向的点可以入队</span><br>        &#123;<br>            <span class="hljs-type">int</span> x = t.first + dx[i];<br>            <span class="hljs-type">int</span> y = t.second + dy[i];<br>            <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="hljs-number">0</span> &amp;&amp; d[x][y] == <span class="hljs-number">-1</span>)  <span class="hljs-comment">//要能走且没走过</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;); <br>                d[x][y] = d[t.first][t.second] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>            cin &gt;&gt; g[i][j];<br>    <span class="hljs-built_in">BFS</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>():<br>    queue = deque([])<br>    queue.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])    <br>    idx = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>    idy = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">while</span> queue:<br>        cur = queue.popleft()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            x = cur[<span class="hljs-number">0</span>] + idx[i]<br>            y = cur[<span class="hljs-number">1</span>] + idy[i]<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; m <span class="hljs-keyword">and</span> mark[x][y] == -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> maze[x][y] == <span class="hljs-number">0</span>:<br>                queue.append([x,y])<br>                mark[x][y] = mark[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mark[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br>        <br>    <br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    maze = [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    mark = [[-<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    mark[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">print</span>(bfs())<br></code></pre></td></tr></table></figure>





<h4 id="2-2-八数码"><a href="#2-2-八数码" class="headerlink" title="2.2 八数码"></a>2.2 八数码</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs tap">在一个 3×3的网格中，1∼8这 8个数字和一个 x 恰好不重不漏地分布在这 3×3的网格中。<br>例如：<br>1<span class="hljs-number"> 2 </span>3<br>x<span class="hljs-number"> 4 </span>6<br>7<span class="hljs-number"> 5 </span>8<br>在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。<br>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：<br>1<span class="hljs-number"> 2 </span>3<br>4<span class="hljs-number"> 5 </span>6<br>7<span class="hljs-number"> 8 </span>x<br>例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。<br>交换过程如下：<br>1<span class="hljs-number"> 2 </span>3  <span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span> <span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span> <span class="hljs-number"> 1 </span>2 3<br>x<span class="hljs-number"> 4 </span>6  <span class="hljs-number"> 4 </span>x<span class="hljs-number"> 6 </span> <span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span> <span class="hljs-number"> 4 </span>5 6<br>7<span class="hljs-number"> 5 </span>8  <span class="hljs-number"> 7 </span>5<span class="hljs-number"> 8 </span> <span class="hljs-number"> 7 </span>x<span class="hljs-number"> 8 </span> <span class="hljs-number"> 7 </span>8 x<br>现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。<br>输入格式<br>输入占一行，将 3×3的初始网格描绘出来。<br>例如，如果初始网格如下所示：<br>1<span class="hljs-number"> 2 </span>3 <br>x<span class="hljs-number"> 4 </span>6 <br>7<span class="hljs-number"> 5 </span>8 <br>则输入为：1<span class="hljs-number"> 2 </span>3 x<span class="hljs-number"> 4 </span>6<span class="hljs-number"> 7 </span>5 8<br>输出格式<br>输出占一行，包含一个整数，表示最少交换次数。<br>如果不存在解决方案，则输出 −1。<br><br>输入样例：<br>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 1 </span>5 x<span class="hljs-number"> 7 </span>6 8<br>输出样例<br>19<br></code></pre></td></tr></table></figure>

<ul>
<li><p>思路</p>
<ul>
<li>该如何表示各个状态？直接用一维的字符串表示</li>
<li>将变换的次数转换为到初始状态的距离</li>
<li>如何存储该状态到初始状态的距离呢？ 状态是用字符串表示的，相当于要&#x3D;&#x3D;根据字符串找到数据&#x3D;&#x3D;，可以用哈希或者map</li>
<li>BFS，每个结点都是一种状态</li>
</ul>
<p>  <img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E5%85%AB%E6%95%B0%E7%A0%81.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(string start)</span></span><br><span class="hljs-function"></span>&#123;<br>    string end  = <span class="hljs-string">&quot;12345678x&quot;</span>;   <span class="hljs-comment">//标准答案</span><br>    <br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; d; <span class="hljs-comment">//用于存储状态到原始状态的距离（状态是字符串型，要通过字符串找对应的数字，想到用map）</span><br>    d[start] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;string&gt; q;   <span class="hljs-comment">//辅助队列，用于存储状态（字符串）</span><br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;  <span class="hljs-comment">//向量数组，用于存储偏移量</span><br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())    <br>    &#123;<br>        string t = q.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">if</span>(t == end) <span class="hljs-keyword">return</span> d[t];   <span class="hljs-comment">//如果此时已经有了标准答案，则退出</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> distance = d[t];<br>        <span class="hljs-type">int</span> p = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);     <span class="hljs-comment">//找到此时x的下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)  <span class="hljs-comment">//找下一步该push哪种状态</span><br>        &#123;<br>            <span class="hljs-type">int</span> x = p / <span class="hljs-number">3</span> + dx[i], y = p % <span class="hljs-number">3</span> + dy[i]; <span class="hljs-comment">//将一维的状态转换为二维的数组，横坐标/n， 纵坐标%n</span><br>            <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; <span class="hljs-number">3</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; <span class="hljs-number">3</span>)   <span class="hljs-comment">//变化后的状态没越界</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(t[p], t[x * <span class="hljs-number">3</span> + y]);   <span class="hljs-comment">//得到改变后的状态，x*3+y是在一维字符串中的下标</span><br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(t))    <span class="hljs-comment">//改变后的状态并未被访问过</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(t);     <span class="hljs-comment">//可入队</span><br>                    d[t] = distance + <span class="hljs-number">1</span>; <br>                &#125;<br>                <span class="hljs-built_in">swap</span>(t[p], t[x * <span class="hljs-number">3</span> + y]);  <span class="hljs-comment">//要恢复上一个状态，便于判断下一种变化</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">//若没在循环内结束，说明没有答案</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string start;<br>    <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];    <span class="hljs-comment">//因为输入包含空格</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>    &#123;<br>        cin &gt;&gt; op;<br>        start += *op; <span class="hljs-comment">//本质上都是数字，可以直接+=</span><br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">BFS</span>(start);<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>dx = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">start</span>):<br>    end = <span class="hljs-string">&quot;12345678x&quot;</span>    <br>    d = &#123;start:<span class="hljs-number">0</span>&#125;      <span class="hljs-comment"># 记录每个状态的交换次数，初始状态为0</span><br>    q = deque([start]) <span class="hljs-comment"># 记录队列头结点到了哪个状态</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q):<br>        t = q.popleft()    <span class="hljs-comment"># 头结点出队</span><br>        distance = d[t]   <span class="hljs-comment"># 保存当前头结点距离初始状态的交换次数</span><br>        <span class="hljs-keyword">if</span> t == end:<br>            <span class="hljs-keyword">return</span> distance<br>        <br>        idx = t.find(<span class="hljs-string">&#x27;x&#x27;</span>)   <span class="hljs-comment"># 找该状态下x的位置，交换顺序</span><br>        x = idx // <span class="hljs-number">3</span><br>        y = idx % <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            a = x + dx[i]<br>            b = y + dy[i]<br>            <span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> a &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> b &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b &lt; <span class="hljs-number">3</span>:<br>                <span class="hljs-comment"># python字符串不能够交换，所以先转成列表再交换</span><br>                t = <span class="hljs-built_in">list</span>(t)<br>                t[idx],t[a * <span class="hljs-number">3</span> + b] = t[a * <span class="hljs-number">3</span> + b],t[idx]<br>                t = <span class="hljs-string">&#x27;&#x27;</span>.join(t)<br>                <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:    <span class="hljs-comment"># 如果新的状态不在字典里</span><br>                    <span class="hljs-comment"># 添加新的状态进入字典并且赋值为上一个状态的交换次数 + 1</span><br>                    d[t] = distance + <span class="hljs-number">1</span><br>                    q.append(t)       <span class="hljs-comment"># 将新的状态入队</span><br>                t = <span class="hljs-built_in">list</span>(t)            <span class="hljs-comment"># 记得一定要回退状态</span><br>                t[idx],t[a * <span class="hljs-number">3</span> + b] = t[a * <span class="hljs-number">3</span> + b],t[idx]<br>                t = <span class="hljs-string">&#x27;&#x27;</span>.join(t)<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>n = <span class="hljs-built_in">input</span>().split()<br>start = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> n:<br>    start += c<br><br><span class="hljs-built_in">print</span>(bfs(start))<br></code></pre></td></tr></table></figure>





<h3 id="3、树的DFS-（O（n-m））"><a href="#3、树的DFS-（O（n-m））" class="headerlink" title="3、树的DFS （O（n*m））"></a>3、树的DFS （O（n*m））</h3><p>用链表数组存储树，一次次进行add操作创建树，每个结点都有一个链表，链接该节点所有直接链接的子节点，如</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">                 1<br>                / \<br>              <span class="hljs-number"> 5 </span>  4<br>              /   / \<br>            <span class="hljs-number"> 6 </span> <span class="hljs-number"> 2 </span>  9<br>             <br>1 :<span class="hljs-number"> 5 </span>-&gt; 4<br>5: 6<br>4:<span class="hljs-number"> 2 </span>-&gt; 9<br>6、2、9: -1<br></code></pre></td></tr></table></figure>



<h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一颗树，树中包含 <span class="hljs-built_in">n</span>个结点（编号 <span class="hljs-number">1</span>∼<span class="hljs-built_in">n</span>）和 <span class="hljs-built_in">n</span>−<span class="hljs-number">1</span> 条无向边。<br>请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。<br>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>，表示树的结点数。<br>接下来 <span class="hljs-built_in">n</span>−<span class="hljs-number">1</span>行，每行包含两个整数 a和 b，表示点 a 和点 b之间存在一条边。<br><br>输出格式<br>输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。<br></code></pre></td></tr></table></figure>



<ul>
<li>原理</li>
</ul>
<p>就暴力地枚举删除每一个结点后的结果，从中找到最小值。</p>
<p>树的深度优先遍历可以很好地求出以树的每个顶点为根的子树的结点数量。</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2</span> * N; <span class="hljs-comment">//最多（2N - 2）条边</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx; <span class="hljs-comment">//e存所连的点，h存每个顶点的头结点</span><br><span class="hljs-type">bool</span> st[N];  <span class="hljs-comment">//st看这个点是否被访问,bfs和dfs都需要这个数组，每个点都只能被访问一次</span><br><span class="hljs-type">int</span> ans = N, m;  <span class="hljs-comment">//ans为最终答案，m为顶点数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>  <span class="hljs-comment">//从a到b建立单向边</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> <span class="hljs-comment">//返回以k为根的子树的结点数</span></span><br><span class="hljs-function"></span>&#123;<br>    st[k] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//标记已访问</span><br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//size记录删除k结点后子树节点数的最大值，sum记录子树的节点数（不包括根结点）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])<br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-built_in">DFS</span>(j);<br>            sum += s;<br>            size = <span class="hljs-built_in">max</span>(size, s);<br>        &#125;<br>    &#125;<br>    size = <span class="hljs-built_in">max</span>(size, m - sum - <span class="hljs-number">1</span>);<br>    ans = <span class="hljs-built_in">min</span>(size, ans);<br>    <span class="hljs-keyword">return</span> sum + <span class="hljs-number">1</span>;   <span class="hljs-comment">//返回以k为根的子树的节点数（包括根结点）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));  <span class="hljs-comment">//头结点初始化为-1（都为空）</span><br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) <span class="hljs-comment">//m个顶点， m-1条边</span><br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);    <span class="hljs-comment">//无向图，要建立双向边</span><br>        <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//随便从哪个点开始都行</span><br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>易错：st数组没更新</p>
<p>  ​            无向图要建立双向边</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>M = <span class="hljs-number">2</span> * N<br>e = [<span class="hljs-number">0</span>] * M<br>ne = [<span class="hljs-number">0</span>] * M<br>h = [-<span class="hljs-number">1</span>] * N<br>idx = <span class="hljs-number">0</span><br>st = [<span class="hljs-literal">False</span>] * N<br>ans = N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-keyword">global</span> ans<br>    st[u] = <span class="hljs-literal">True</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">1</span> <br>    res = <span class="hljs-number">0</span><br>    i = h[u]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        j = e[i]<br>        <span class="hljs-keyword">if</span> st[j] != <span class="hljs-literal">True</span>:<br>            s = dfs(j)<br>            res = <span class="hljs-built_in">max</span>(res, s)<br>            <span class="hljs-built_in">sum</span> += s <br>        i = ne[i]<br>    res = <span class="hljs-built_in">max</span>(res, n - <span class="hljs-built_in">sum</span>)<br>    ans = <span class="hljs-built_in">min</span>(ans, res)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br>        <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b)<br>        add(b, a)<br>    dfs(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure>





<h3 id="4、树的BFS（O-n-m-）"><a href="#4、树的BFS（O-n-m-）" class="headerlink" title="4、树的BFS（O(n*m)）"></a>4、树的BFS（O(n*m)）</h3><ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环。<br>所有边的长度都是 <span class="hljs-number">1</span>，点的编号为 <span class="hljs-number">1</span>∼<span class="hljs-built_in">n</span>。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果从 <span class="hljs-number">1</span>号点无法走到 <span class="hljs-built_in">n</span>号点，输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含两个整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行，每行包含两个整数 a和 b，表示存在一条从 a走到 b的长度为 <span class="hljs-number">1</span>的边。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br></code></pre></td></tr></table></figure>



<ul>
<li><p>思路</p>
<p>  求的是最短距离，并且边之间的距离都是1，可以用BFS求最短路</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> e[N], ne[N], h[N], d[N], idx;  <span class="hljs-comment">//d数组既记录结点到1号点的距离，又作为是否被访问的标志</span><br><span class="hljs-type">int</span> n, m;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//从1号点开始</span><br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">if</span>(t == n) <span class="hljs-keyword">return</span> d[t];<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) <span class="hljs-comment">//h的值是idx，e[idx]才是结点的编号</span><br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">BFS</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>queue = deque()<br>N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>M = <span class="hljs-number">2</span> * N<br>e = [<span class="hljs-number">0</span>] * N<br>ne = [<span class="hljs-number">0</span>] * M<br>h = [-<span class="hljs-number">1</span>] * N<br>d = [-<span class="hljs-number">1</span>] * N<br>idx = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b <br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>():<br>    queue.append(<span class="hljs-number">1</span>)<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> queue:<br>        cur = queue.popleft()<br>        i = h[cur]<br>        <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>            s = e[i]<br>            <span class="hljs-keyword">if</span> d[s] == -<span class="hljs-number">1</span>:<br>                d[s] = d[cur] + <span class="hljs-number">1</span> <br>                queue.append(s)<br>            i = ne[i]<br>    <span class="hljs-keyword">return</span> d[n]<br>            <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b)<br>    <span class="hljs-built_in">print</span>(bfs())<br></code></pre></td></tr></table></figure>



<h3 id="5、有向图的拓扑序列"><a href="#5、有向图的拓扑序列" class="headerlink" title="5、有向图的拓扑序列"></a>5、有向图的拓扑序列</h3><ul>
<li>只有有向无环图才又拓扑序列</li>
<li>何为拓扑序列？</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>思路：</li>
</ul>
<p>类似于BFS，不断将入度为0的点入队，再出队得到队头元素，要删去它，则要遍历它的每一个邻点，将它们的入度减一，如果减去后邻点的入度为0，则将这个邻点入队，一直循环下去直至队空。</p>
<p>如果队空时，刚好已经遍历完了所有的顶点，那么可以拓扑排序，按顺序输出队列即为拓扑排序的结果</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> e[N], ne[N], h[N], idx;<br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;   <span class="hljs-comment">//用数组模拟队列，如果用STL的话，队列是不透明的，反而不能获得里面的信息，除非再开一个数组储存出队元素</span><br><span class="hljs-type">int</span> d[N];   <span class="hljs-comment">//d数组用于储存顶点的入度</span><br><span class="hljs-type">int</span> m, n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>    d[b] ++;   <span class="hljs-comment">//入读加一</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">//先将入度为0的点全部入队</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)<br>            q[++tt] = i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)  <span class="hljs-comment">//类似于BFS</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh++]; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            d[e[i]] --;  <span class="hljs-comment">//删去队头的顶点，将与队头元素相连的点的入度减一</span><br>            <span class="hljs-keyword">if</span>(d[e[i]] == <span class="hljs-number">0</span>) <span class="hljs-comment">//删去后入度为0，可以入队</span><br>                q[++tt] = e[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tt == (n - <span class="hljs-number">1</span>);  <span class="hljs-comment">//如果队中刚刚好走过了n个顶点，说明有拓扑序列</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">topsort</span>())<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>M = <span class="hljs-number">2</span> * N<br>e = [<span class="hljs-number">0</span>] * N<br>ne = [<span class="hljs-number">0</span>] * M<br>h = [-<span class="hljs-number">1</span>] * N<br>d = [<span class="hljs-number">0</span>] * N<br>q = [<span class="hljs-number">0</span>] * N<br>hh, tt = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>idx = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span> <br>    d[b] += <span class="hljs-number">1</span> <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">topsort</span>():<br>    <span class="hljs-keyword">global</span> tt, hh<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> d[i] == <span class="hljs-number">0</span>:<br>            tt += <span class="hljs-number">1</span> <br>            q[tt] = i<br>    <span class="hljs-keyword">while</span> hh &lt;= tt:<br>        cur = q[hh]<br>        hh += <span class="hljs-number">1</span> <br>        i = h[cur]<br>        <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>            j = e[i]<br>            d[j] -= <span class="hljs-number">1</span> <br>            <span class="hljs-keyword">if</span> d[j] == <span class="hljs-number">0</span>:<br>                tt += <span class="hljs-number">1</span> <br>                q[tt] = j<br>            i = ne[i]<br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b)<br>    <span class="hljs-keyword">if</span> topsort():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-built_in">print</span>(q[i], end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>





<h3 id="6、最短路"><a href="#6、最短路" class="headerlink" title="6、最短路"></a>6、最短路</h3><ul>
<li>单源最短路（求一个起点到其他所有点的最短路径）<ul>
<li><p>所有权都是1</p>
<ul>
<li>BFS</li>
</ul>
</li>
<li><p>所有边的权都是正数</p>
<ul>
<li>朴素Dijkstra算法    O(n^2)适用于稠密图</li>
<li>堆优化版的Dijkstra算法   O(mlogn)  适用于稀疏图</li>
</ul>
</li>
<li><p>存在权是负数的边</p>
<ul>
<li>Bellman_Ford   O(nm)   &#x3D;&#x3D;对经过的边数有限制时用&#x3D;&#x3D;，可判断负环，负环存在时可以求出限制k条边的最短路径</li>
<li>SPFA     O(m) ~ O(nm)     优于Bellman，可判断负环，要求求最短路的话不能存在负环</li>
</ul>
</li>
</ul>
</li>
<li>多源汇最短路（随机求两个点间的最短路径）<ul>
<li>Floyd  O(n^3)</li>
</ul>
</li>
</ul>
<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20250207110642707.png" srcset="/img/loading.gif" lazyload alt="image-20250207110642707" style="zoom: 50%;" />



<p><strong>无向图是特殊的有向图，模板都是一样的，区别是无向图建边时要建立双向的</strong></p>
<h4 id="6-1、-朴素Dijkstra算法"><a href="#6-1、-朴素Dijkstra算法" class="headerlink" title="6.1、 朴素Dijkstra算法"></a>6.1、 朴素Dijkstra算法</h4><ul>
<li>解决没负权的单源最短路问题（稠密图）</li>
<li>时间复杂度分析：找距离最近的未被访问的点 O(n^2)    (找n次，每次遍历n个顶点)</li>
</ul>
<p>更新邻边O(m)                        总：O(m + n^2) &#x3D; O(n^2)</p>
<ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 impossible。<br>数据保证不存在负权回路。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br>如果路径不存在，则输出 impossible。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N], dist[N]; <span class="hljs-comment">//g存图， dist存权重</span><br><span class="hljs-type">bool</span> st[N];    <span class="hljs-comment">//st判断该点是否已经在最短路中</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//1号点自己到自己的距离是0</span><br>    <br>    <span class="hljs-comment">//1、先找没在最短路中的又离最短路最近的点，把它加入最短路</span><br>    <span class="hljs-comment">//2、遍历更新这个点的相邻顶点到最短路的距离</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-comment">//进行n次循环</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//技巧，便于确定第一个没加入最短路的点的下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        &#125;<br>        st[t] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//加入最短路，起点也是在这里被加入最短路的，要不然上面的循环进不去</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)  <span class="hljs-comment">//更新</span><br>        &#123;<br>            dist[k] = <span class="hljs-built_in">min</span>(dist[k], dist[t] + g[t][k]);   <span class="hljs-comment">//不用管k点有没有与t点相连，没有相连的话dist[k]一直都是INF </span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);  <span class="hljs-comment">//可能有重边和环，有重边的话只用考虑重边中最短的那一条</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">Dijkstra</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">510</span>)<br>M = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>e = [<span class="hljs-number">0</span>] * N<br>h = [-<span class="hljs-number">1</span>] * N<br>ne = [<span class="hljs-number">0</span>] * M<br>w = [<span class="hljs-number">0</span>] * M<br>idx = <span class="hljs-number">0</span><br>dist = [<span class="hljs-number">0x3f</span>] * N<br>st = [<span class="hljs-literal">False</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    w[idx] = c<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Dijkstra</span>():<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        t = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> st[i] == <span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (t == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> dist[i] &lt; dist[t]):<br>                t = i<br>        st[t] = <span class="hljs-literal">True</span><br>        i = h[t]<br>        <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>            j = e[i]<br>            <span class="hljs-keyword">if</span> dist[j] &gt; dist[t] + w[i]:<br>                dist[j] = dist[t] + w[i]<br>            i = ne[i]<br>        <br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b, c)<br>    Dijkstra()<br>    <span class="hljs-keyword">if</span> dist[n] == <span class="hljs-number">0x3f</span>:<br>        <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(dist[n])<br></code></pre></td></tr></table></figure>





<h4 id="6-2-堆优化的Dijkstra算法"><a href="#6-2-堆优化的Dijkstra算法" class="headerlink" title="6.2\堆优化的Dijkstra算法"></a>6.2\堆优化的Dijkstra算法</h4><ul>
<li>解决没负权的单源最短路问题（稀疏图）</li>
<li>朴素dijkstra算法的主要耗时的步骤是从dist 数组中选出没有确定最短路径的节点中距离源点最近的点 t，n个结点，每个点选n次，则是O(n^2)。只是找个最小值而已，没有必要每次遍历一遍dist数组，在一组数中每次能很快的找到最小值，很容易想到使用小根堆（优先级队列）。</li>
<li>时间复杂度分析：   找距离最近的未访问结点 O(n)      n次top， 每次O(1)</li>
</ul>
<p>更新邻边O(mlogn)      m次更新， 每次logn                总O(mlogn + n) &#x3D; O(mlogn)</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N  = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;  <span class="hljs-comment">//&lt;权值， 编号&gt;</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], w[N], idx;    <span class="hljs-comment">//优先级队列要搭配邻接表</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N]; <br>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;  <span class="hljs-comment">//自定义为最小堆</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">//并不是说一开始就把全部点入队，而是更新了对应的dist后才把它入队</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())  <br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br>        <span class="hljs-keyword">if</span>(st[ver])   <span class="hljs-comment">//更新了dist数组然后入队后队列中可能会有一个点的多个数据对，但取出其最小的一个后把它标记为true，之后又出队的相同的点会直接省略， 重边也是这样滤去的</span><br>            <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])  <span class="hljs-comment">//遍历的点全是邻接点</span><br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">Dijkstra</span>() ;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5005</span>)<br>M = <span class="hljs-number">2</span> * N<br>e = [<span class="hljs-number">0</span>] * M<br>w = [<span class="hljs-number">0</span>] * M<br>ne = [<span class="hljs-number">0</span>] * M<br>h = [-<span class="hljs-number">1</span>] * N<br>dist = [<span class="hljs-number">0x3f3f3f3f</span>] * N<br>st = [<span class="hljs-literal">False</span>] * N<br>idx = <span class="hljs-number">0</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    w[idx] = c<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Dijkstra</span>():<br>    heap = []<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    heapq.heappush(heap, (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">while</span> heap:<br>        distance, node = heapq.heappop(heap)<br>        <span class="hljs-keyword">if</span> st[node] == <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">continue</span><br>        st[node] = <span class="hljs-literal">True</span><br>        i = h[node]<br>        <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>            j = e[i]<br>            <span class="hljs-keyword">if</span> dist[j] &gt; dist[node] + w[i]:<br>                dist[j] = dist[node] + w[i]<br>                heapq.heappush(heap, (dist[j], j))<br>            i = ne[i] <br>        <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b, c)<br>    Dijkstra()<br>    <span class="hljs-keyword">if</span> dist[n] == <span class="hljs-number">0x3f3f3f3f</span>:<br>        <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(dist[n])<br></code></pre></td></tr></table></figure>





<h4 id="6-3Bellman-Ford算法"><a href="#6-3Bellman-Ford算法" class="headerlink" title="6.3Bellman_Ford算法"></a>6.3Bellman_Ford算法</h4><ul>
<li><p>原理：</p>
<ul>
<li>如果对最短路径的&#x3D;&#x3D;边数有限制&#x3D;&#x3D;的话，最多经历n次循环之后，该找到最短路径的一定都能找到最短路径，没有最短路径的就找不到（有负权边陷入了无限循环 || 不连通）， 每次循环中都会遍历所有边，能松弛的就松弛（d[b] &gt; d[a] + w）。</li>
<li>在第n次循环之时若还有点的dist更新了的话，那些点就不存在最短路径，也可以通过这个判断图存在负环。 </li>
<li>循环的次数k也是有意义的：不多于k条边组成的最短路径。因此，当对最短路径有限制k条边时，就进行k次循环就行了。</li>
<li>负权回路   （有负权回路会对经过它能够到达的顶点4造成影响，却不会对5造成影响）</li>
</ul>
</li>
</ul>
<p>![](..&#x2F;..&#x2F;..&#x2F;Desktop&#x2F;总&#x2F;算法&#x2F;算法图解&#x2F;Bellmanford 中的负权回路2.png)</p>
<p>​         为何设立backup数组？备份上一次迭代得到的dist数组，防止本次迭代中更新的dist影响其他点的dist的更新</p>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/Bellman%E4%B8%B2%E8%81%94%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br><br>请你求出从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，输出 impossible。<br>注意：图中可能 存在负权回路 。<br>输入格式<br>第一行包含三个整数 <span class="hljs-built_in">n</span>,m,k。<br>接下来 m行，每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br>点的编号为 <span class="hljs-number">1</span>∼<span class="hljs-built_in">n</span>。<br>输出格式<br>输出一个整数，表示从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离。<br>如果不存在满足条件的路径，则输出 impossible。<br></code></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;注意题目中有边数限定&#x3D;&#x3D;,算法迭代k次，代表起点到各个点不超过k条边的最短路径</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> dist[N], backup[N]; <span class="hljs-comment">//backup数组用于拷贝dist数组，防止更新时出现串联</span><br><span class="hljs-keyword">struct</span>             <span class="hljs-comment">//只用遍历边，用结构体存储边就行了</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)   <span class="hljs-comment">//要求最多k条边， 即要经历k次循环</span><br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);  <span class="hljs-comment">//每次更新前先拷贝</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)   <span class="hljs-comment">//遍历每条边</span><br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + w);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>)    <span class="hljs-comment">// 大于足够大数而不是==0x3f，因为有时候可能会负权边干扰</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        edges[i] = &#123;a, b, c&#125;;<br>    &#125;<br>    <span class="hljs-built_in">Bellman_Ford</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">M = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>inf = <span class="hljs-built_in">int</span>(<span class="hljs-number">0x3f3f3f3f</span>)<br>dist = [inf] * M<br>edges = []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Bellman</span>():<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>        backup = dist.copy()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            a, b, c = edges[i]<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + c)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        edges.append([a, b, c])<br>    Bellman()<br>    <span class="hljs-keyword">if</span> dist[n] &gt; inf // <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;impossible&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(dist[n])<br></code></pre></td></tr></table></figure>



<h4 id="6-4-spaf算法-最坏O-nm"><a href="#6-4-spaf算法-最坏O-nm" class="headerlink" title="6.4 spaf算法 最坏O(nm)"></a>6.4 spaf算法 最坏O(nm)</h4><p>spfa算法是对Bellman_Ford算法的优化，后者每次循环都要暴力的遍历每一条边，但实际上，参考dist[j] &#x3D; dist[i] + w，只有当i的dist更新了之后，dist[j]才会跟着更新。spfa就是根据这一点进行的优化，只对更新了dist数组的顶点进行遍历，更新&#x3D;&#x3D;以它为起点&#x3D;&#x3D;的边。</p>
<p>有负环时spfa算法会陷入无限循环</p>
<ul>
<li>原理：创建一个辅助队列，当队列不为空之时，出队队头元素，进行遍历更新，更新的顶点如果不在队列中的，就可以入队。</li>
<li>代码（实际上能用Dijkstra算法的一般都能用spfa解决，速度可能还更快）</li>
<li>spfa其实非常像堆优化的Dijkstra算法，区别在于spfa顶点的st是可以反复变化的，表示当前顶点是否在队列中，当顶点的dist更新了，如果顶点在队列中则不用入队，否则要入队；而Dijstra顶点的st是不可反复变化的，表示当前顶点是否找到最短路径，当顶点的dist更新，无论如何都要入队</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx, dist[N], w[N];<br><span class="hljs-type">bool</span> st[N];    <span class="hljs-comment">//st数组用于记录该点是否在队列中</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;      <span class="hljs-comment">//出队立刻更新st</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span>(!st[j])       <span class="hljs-comment">//如果顶点j更新了dist且j不在队列中，则j入队</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>        <br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>e = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> * N<br>ne = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> * N<br>h = [-<span class="hljs-number">1</span>] * N<br>idx = <span class="hljs-number">0</span><br>w = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> * N<br>queue = deque([])<br>dist = [<span class="hljs-number">0x3f3f3f3f</span>] * N<br>st = [<span class="hljs-literal">False</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    w[idx] = c<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span> <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Spfa</span>():<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> <br>    queue.append([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">while</span> queue:<br>        distance, node = queue.popleft()<br>        st[node] = <span class="hljs-literal">False</span><br>        i = h[node]<br>        <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>            j = e[i]<br>            <span class="hljs-keyword">if</span> dist[j] &gt; dist[node] + w[i]:<br>                dist[j] = dist[node] + w[i]<br>                <span class="hljs-keyword">if</span> st[j] != <span class="hljs-literal">True</span>:<br>                    st[j] = <span class="hljs-literal">True</span><br>                    queue.append([dist[j], j])<br>            i = ne[i]<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b, c)<br>    Spfa()<br>    <span class="hljs-keyword">if</span> dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> // <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;impossible&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(dist[n])<br></code></pre></td></tr></table></figure>





<ul>
<li>判断负环</li>
</ul>
<p>用了抽屉原理，如果某条最短路径的边数&gt;&#x3D;n,说明这条路径最少有n+1个顶点，但实际上只有n个顶点，说明路径上有重复经过的点，只有存在负环的时候才会出现这种情况</p>
<p>与原始的spfa算法不同，判断负环时要求将所有结点入队，并且dist数组初始化为0而不是无穷。相当给原图多加一个虚拟结点“0”，所有点到该结点的距离为0，将0结点出队，并将与0结点相连的所有结点入队。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>, N = <span class="hljs-number">2010</span>;<br><span class="hljs-type">int</span> ne[M], e[M], w[M], h[N], idx;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> cnt[N], dist[N];  <span class="hljs-comment">//cnt用于记录当前最短路的边数，若边数大于等于n，根据抽屉原理，存在负环</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;   <span class="hljs-comment">//dist不用初始化了</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    w[idx] = c;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)   <span class="hljs-comment">//先把全部顶点入队，可以想象有一个不存在的起点‘0’连接着所有边，将‘0’出队后将所有的相连顶点入队</span><br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i]) <span class="hljs-comment">//纵使dist没初始化，当w为负数时也会更新</span><br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> <br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>e = [<span class="hljs-number">0</span>] * N * <span class="hljs-number">2</span><br>ne = [<span class="hljs-number">0</span>] * N * <span class="hljs-number">2</span><br>h = [-<span class="hljs-number">1</span>] * N<br>idx = <span class="hljs-number">0</span><br>w = [<span class="hljs-number">0</span>] * N * <span class="hljs-number">2</span><br>dist = [<span class="hljs-number">0</span>] * N<br>st = [<span class="hljs-literal">False</span>] * N<br>cnt = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    w[idx] = c<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Spfa</span>():<br>    queue = deque()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        queue.append((dist[i], i))<br>    queue.append((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">while</span> queue:<br>        distance, node = queue.popleft()<br>        st[node] = <span class="hljs-literal">False</span><br>        i = h[node]<br>        <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>            j = e[i]<br>            <span class="hljs-keyword">if</span> dist[j] &gt; dist[node] + w[i]:<br>                dist[j] = dist[node] + w[i]<br>                cnt[j] = cnt[node] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> cnt[j] &gt;= n:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> st[j] != <span class="hljs-literal">True</span>:<br>                    st[j] = <span class="hljs-literal">True</span><br>                    queue.append((dist[j], j))<br>            i = ne[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b, c)<br>    res = Spfa()<br>    <span class="hljs-keyword">if</span> res == <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure>





<h4 id="6-5Floyd算法"><a href="#6-5Floyd算法" class="headerlink" title="6.5Floyd算法"></a>6.5Floyd算法</h4><ul>
<li><p>原理：动态规划 ： d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]),    k是途径的中间点，就是每个点都要作为中间点去遍历点到点之间的所有关系，一旦满足关系式的就更新g[i][j]</p>
</li>
<li><p>题目</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">给定一个 n个点 m条边的有向图，图中可能存在重边和自环，边权可能为负数。<br>再给定 k个询问，每个询问包含两个整数 <span class="hljs-attribute">x</span>和 <span class="hljs-attribute">y</span>，表示查询从点 <span class="hljs-attribute">x</span>到点 <span class="hljs-attribute">y</span>的最短距离，如果路径不存在，则输出 impossible。<br>数据保证图中不存在负权回路。<br>输入格式<br>第一行包含三个整数 n,m,k。<br>接下来 m行，每行包含三个整数 <span class="hljs-attribute">x</span>,<span class="hljs-attribute">y</span>,z，表示存在一条从点 <span class="hljs-attribute">x</span>到点 <span class="hljs-attribute">y</span>的有向边，边长为 z。<br>接下来 k行，每行包含两个整数 <span class="hljs-attribute">x</span>,<span class="hljs-attribute">y</span>，表示询问点 <span class="hljs-attribute">x</span>到点 <span class="hljs-attribute">y</span>的最短距离。<br><br>输出格式<br>共 k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 impossible。<br>数据范围<br><span class="hljs-number">1</span>≤n≤<span class="hljs-number">200</span>,<br><span class="hljs-number">1</span>≤k≤n2<br><span class="hljs-number">1</span>≤m≤<span class="hljs-number">20000</span>,<br>图中涉及边长绝对值均不超过 <span class="hljs-number">10000</span>。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;  <span class="hljs-comment">//题目对边的权值有限定</span><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span>   <span class="hljs-comment">//三次循环</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], g[i][k] + g[k][j]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) <br>                g[i][j] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//特意考虑了对角线的情况，若不初始化为0，循环的时候一定会更新，但自己到自己的距离一定是等于0的</span><br>            <span class="hljs-keyword">else</span><br>                g[i][j] = INF;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], w);   <span class="hljs-comment">//滤去重边</span><br>    &#125;<br>    <span class="hljs-built_in">Floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(g[a][b] &gt; INF / <span class="hljs-number">2</span>)  <span class="hljs-comment">//负边会造成一定影响，可能会略小于INF</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; g[a][b] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">210</span>)<br>d = [[<span class="hljs-number">0x3f3f3f3f</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Floyd</span>():<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j])<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i == j:<br>                d[i][j] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], c)<br>    Floyd()<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-keyword">if</span> d[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span> // <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;impossible&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(d[a][b])<br></code></pre></td></tr></table></figure>





<h3 id="7、最小生成树"><a href="#7、最小生成树" class="headerlink" title="7、最小生成树"></a>7、最小生成树</h3><p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>最小生成树的边的权重有重复的话，最小生成树是不唯一的，反之则是唯一的，不管从哪个点开始</strong></p>
<h4 id="7-1-、朴素Prime算法"><a href="#7-1-、朴素Prime算法" class="headerlink" title="7.1 、朴素Prime算法"></a>7.1 、朴素Prime算法</h4><ul>
<li><p>与Dijkstra算法的区别在于更新dist的时候的条件不同</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N], dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> res;    <span class="hljs-comment">//记录最小生成树的总权重</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Prime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;     <span class="hljs-comment">//一开始随便弄个初始点都行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        <br>        <span class="hljs-keyword">if</span>(dist[t] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//说明这个图不连通</span><br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//先更新res在进行更新dist的操作，因为如果有负边的话更新dist的时候可能会把dist[t]也一起更新了</span><br>        res += dist[t];     <span class="hljs-comment">//不是起始点的话就可以更新res</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>           <span class="hljs-keyword">if</span>(dist[j] &gt; g[t][j])<br>           &#123;<br>               dist[j] = g[t][j];<br>           &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Prime</span>())<br>        cout &lt;&lt; res;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">510</span>)<br>M = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>g = [[<span class="hljs-number">0x3f3f3f3f</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>dist = [<span class="hljs-number">0x3f3f3f3f</span>] * N<br>st = [<span class="hljs-literal">False</span>] * N<br>res = <span class="hljs-number">0</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Prime</span>():<br>    <span class="hljs-keyword">global</span> res<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        t = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> st[i] == <span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (t == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> dist[t] &gt; dist[i]):<br>                t = i<br>        <span class="hljs-keyword">if</span> dist[t] == <span class="hljs-number">0x3f3f3f3f</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        st[t] = <span class="hljs-literal">True</span><br>        res += dist[t]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            dist[i] = <span class="hljs-built_in">min</span>(dist[i], g[t][i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c)<br>        g[b][a] = <span class="hljs-built_in">min</span>(g[b][a], c)<br>    flag = Prime()<br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">False</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;impossible&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>





<h4 id="7-2Kruskal算法"><a href="#7-2Kruskal算法" class="headerlink" title="7.2Kruskal算法"></a>7.2Kruskal算法</h4><ul>
<li>原理：</li>
</ul>
<p>先对所有边从小到大进行排序，然后按顺序遍历每一条边，若边的两个顶点不在一个并查集中，则把这条边加入最小树中</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, M = <span class="hljs-number">2</span>*N;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[N], cnt, res; <span class="hljs-comment">//p用于并查集的实现，cnt用于记录最小树中的边数，res用于记录最小树的总权重</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> edge &amp;W) <span class="hljs-type">const</span>  <span class="hljs-comment">//对结构体完成比较必须要重载操作符，要不然怎么知道怎么排序呢</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> c &lt; W.c;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x != p[x]) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].c;<br>        <br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span>(a != b)<br>        &#123;<br>            p[a] = b;<br>            cnt ++;<br>            res += w;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt &lt; n<span class="hljs-number">-1</span>)     <span class="hljs-comment">//遍历完全部边后最小树中的边数应该是n-1，若小于n-1，说明不连通</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;   <span class="hljs-comment">//并查集一定得初始化</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        edges[i] = &#123;a, b, c&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">Kruskal</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>p = [<span class="hljs-number">0</span>] * N<br>edge = []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-keyword">if</span> a != p[a]:<br>        p[a] = find(p[a])<br>    <span class="hljs-keyword">return</span> p[a]<br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    res = <span class="hljs-number">0</span><br>    cnt = <span class="hljs-number">0</span><br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        heapq.heappush(edge, (c, a, b))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        p[i] = i <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        w, a, b = heapq.heappop(edge)<br>        a = find(a)<br>        b = find(b)<br>        <span class="hljs-keyword">if</span> a != b:<br>           res += w<br>           cnt += <span class="hljs-number">1</span><br>           p[a] = b<br>    <span class="hljs-keyword">if</span> cnt == n - <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(res)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;impossible&quot;</span>)<br></code></pre></td></tr></table></figure>





<h3 id="8、染色法判断二分图O-n-m"><a href="#8、染色法判断二分图O-n-m" class="headerlink" title="8、染色法判断二分图O(n+m)"></a>8、染色法判断二分图O(n+m)</h3><ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的无向图，图中可能存在重边和自环。<br>请你判断这个图是否是二分图。<br>输入格式<br>第一行包含两个整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行，每行包含两个整数 u和 v，表示点 u和点 v之间存在一条边。<br>输出格式<br>如果给定图是二分图，则输出 Yes，否则输出 No。<br></code></pre></td></tr></table></figure>



<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>, M = <span class="hljs-number">2</span> *N;<br><span class="hljs-type">int</span> ne[M], e[M], h[N], idx;<br><span class="hljs-type">int</span> color[N];  <span class="hljs-comment">//用于记录点的颜色</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> c)</span> <span class="hljs-comment">//给t号点染上c色</span></span><br><span class="hljs-function"></span>&#123;<br>    color[t] = c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])  <span class="hljs-comment">//对t号点的连通块进行染色</span><br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!color[j])   <span class="hljs-comment">//若j号点未染色</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(j, <span class="hljs-number">3</span> - c))  <span class="hljs-comment">//给j号点染上与它的父节点相反的颜色，若不成功则出错</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[j] == c)  <span class="hljs-comment">//j号点已染色但和它的父节点一样的颜色，出错</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>        <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">//考虑到图可能是不连通的图，则要遍历每一个点，确保每个连通块都染色</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!color[i])     <span class="hljs-comment">//只用对未染色的点（另外一个连通块的点）进行处理</span><br>        &#123;                 <span class="hljs-comment">//染了色的一般都是本连通块的点</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>))<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag)<br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>python代码用dfs会爆栈，所以用bfs</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>M = <span class="hljs-number">2</span> * N<br>e = [<span class="hljs-number">0</span>] * M<br>ne = [<span class="hljs-number">0</span>] * M<br>h = [-<span class="hljs-number">1</span>] * N<br>idx = <span class="hljs-number">0</span><br>color = [<span class="hljs-number">0</span>] * N<br>queue = deque()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span> <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">u, c</span>):  <span class="hljs-comment"># 目的：为u以及与u相连的未染色的顶点染色，同时检查与u相连的已经染色的顶点是否染对色</span><br>    queue.append((u, c))<br>    <span class="hljs-keyword">while</span> queue:<br>        node, w = queue.popleft()<br>        color[node] = w <br>        i = h[node]<br>        <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>            j = e[i]<br>            <span class="hljs-keyword">if</span> color[j] == <span class="hljs-number">0</span>:<br>                queue.append((j, <span class="hljs-number">3</span> - w))<br>            <span class="hljs-keyword">elif</span> color[j] == w:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            i = ne[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b)<br>        add(b, a)<br>    flag = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> color[i] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> bfs(i, <span class="hljs-number">1</span>) == <span class="hljs-literal">False</span>:<br>                flag = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">False</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br></code></pre></td></tr></table></figure>



<h3 id="9、匈牙利算法求二分图的最大匹配数O-nm"><a href="#9、匈牙利算法求二分图的最大匹配数O-nm" class="headerlink" title="9、匈牙利算法求二分图的最大匹配数O(nm)"></a>9、匈牙利算法求二分图的最大匹配数O(nm)</h3><ul>
<li>题目</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">给定一个二分图，其中左半部包含 n1个点（编号 <span class="hljs-number">1</span>∼n1），右半部包含 n2个点（编号 <span class="hljs-number">1</span>∼n2），二分图共包含 m条边。<br>数据保证任意一条边的两个端点都不可能在同一部分中。<br>请你求出二分图的最大匹配数。<br>二分图的匹配：给定一个二分图 <span class="hljs-selector-tag">G</span>，在 <span class="hljs-selector-tag">G</span>的一个子图 M中，M的边集 &#123;E&#125;中的任意两条边都不依附于同一个顶点，则称 M是一个匹配。<br>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。<br>输入格式<br>第一行包含三个整数 n1、 n2和 m。<br>接下来 m行，每行包含两个整数 u 和 v，表示左半部点集中的点 u和右半部点集中的点 v之间存在一条边。<br>输出格式<br>输出一个整数，表示二分图的最大匹配数。<br></code></pre></td></tr></table></figure>

<ul>
<li>原理：</li>
</ul>
<p>与找女朋友类比，有n1个男生，n2个女生，每个男生有若干个暗恋对象，遍历每个男生，对每个男生，依次考虑暗恋对象，若她没有男朋友，则匹配成功；若有男朋友，则要看看她男朋友有没有 没有男朋友 的备胎，若有，则她男朋友与备胎匹配，她与该男生配对。</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n1, n2, m;<br><span class="hljs-type">int</span> h[N], ne[M], e[M], idx;  <span class="hljs-comment">//用邻接表储存图，每个男生做头指针，每个男生对应的暗恋对象做他的链表</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">//判断妹子是否被访问，每次为一个新的男生找妹子时都要更新，但在一个find函数的过程中，会有find(match[j])，直接不考虑st已经标记了的妹子</span><br><span class="hljs-type">int</span> match[N]; <span class="hljs-comment">//记录女生匹配的男生编号</span><br><span class="hljs-type">int</span> res; <span class="hljs-comment">//记录匹配数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">//找到男生x匹配的女生</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])  <span class="hljs-comment">//遍历男生要考虑的妹子</span><br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])  <span class="hljs-comment">//妹子还没匹配过,防止j的男友又找j</span><br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) <span class="hljs-comment">//当前妹子还没匹配别的男生，或者与其匹配的男生可以找到备胎</span><br>            &#123;<br>                match[j] = x; <span class="hljs-comment">//该妹子与该男生匹配成功</span><br>                <span class="hljs-comment">//不可直接在这里res++， 若在这里res++的话，find(match[j]) 也可能会使得res+1，但实际上只是转移了男生match[j]的对象并不会使res+1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//匹配成功就不用考虑剩下的女生了</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++)  <span class="hljs-comment">//为每一个男生都找妹子</span><br>    &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st); <span class="hljs-comment">//清空要考虑的女生</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i))    <span class="hljs-comment">//匹配成功，res加一</span><br>            res++;<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">510</span>)<br>M = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>e = [<span class="hljs-number">0</span>] * M<br>ne = [<span class="hljs-number">0</span>] * M<br>idx = <span class="hljs-number">0</span><br>h = [-<span class="hljs-number">1</span>] * N<br><span class="hljs-keyword">match</span> = [<span class="hljs-number">0</span>] * N<br>st = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    i = h[x]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:<br>        j = e[i]<br>        <span class="hljs-keyword">if</span> st[j] != <span class="hljs-number">1</span>:<br>            st[j] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>[j] == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> find(<span class="hljs-keyword">match</span>[j]):<br>                <span class="hljs-keyword">match</span>[j] = x<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        i = ne[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    n1, n2, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(a, b)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n1+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n2+<span class="hljs-number">1</span>):<br>            st[j] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> find(i):<br>            res += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>





<h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><p>用于求解某种具有最优性质的问题。在这类问题中可能会有许多可行解，我们希望找到最优解</p>
<p>基本思想 是将问题分解未若干个子问题，先求解子问题，然后从这些子问题的解中得到原有问题的解，动态规划的这些子问题都是有关联的，一般都是逐层更新得出的。</p>
<p>动态规划问题：</p>
<ul>
<li>集合含义</li>
<li>状态转移方程</li>
<li>初始化问题</li>
</ul>
<h3 id="4-1、背包问题"><a href="#4-1、背包问题" class="headerlink" title="4.1、背包问题"></a>4.1、背包问题</h3><ul>
<li><p>分类</p>
<ul>
<li>01背包问题 ： 每个物体只能被拿一次</li>
<li>完全背包问题 ： 每个物体可以被拿多次（没有限制）</li>
<li>多重背包问题 ： 每个物体最多可以拿Si次</li>
<li>分组背包问题 ： 每&#x3D;&#x3D;类&#x3D;&#x3D;物体最多可以拿一个</li>
</ul>
</li>
</ul>
<h4 id="4-1-1-01背包问题"><a href="#4-1-1-01背包问题" class="headerlink" title="4.1.1 01背包问题"></a>4.1.1 01背包问题</h4><ul>
<li><p>状态表示  f(i, j) —&gt;从1~i号元素中寻找总体积不大于j的所有选法中权重的最大值</p>
<ul>
<li>集合<ul>
<li>所有选法 的集合</li>
</ul>
</li>
<li>属性(此处分析默认属性为MAX)<ul>
<li>最大值、最小值、个数</li>
</ul>
</li>
</ul>
</li>
<li><p>状态计算（集合的划分）</p>
<ul>
<li>分为两个集合，一个是不包含第i个物品的选法，一个是包含第i个物品的选法</li>
<li>等价于：一个从1~i-1号物品中选总体积小于j的选法的集合，一个是从1~i号物品中选总体积小于j的包含i号物品的集合</li>
<li>集合二必选i号物品，即f(i - 1, j - v<del>i</del> ) 少了一个i号物品的权重，则加上一个权重w<del>i</del> 即f(i, j)(包含j号物品) &#x3D; f(i - 1, j - v<del>i</del> ) + w<del>i</del> </li>
<li>f(i, j) &#x3D; max( f( i - 1 , j ) , ( f (i - 1, j - v<del>i</del> ) + w<del>i</del> ) )</li>
</ul>
</li>
<li><p>题目</p>
  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">有 <span class="hljs-keyword">N</span>件物品和一个容量是 V的背包。每件物品只能使用一次。<br>第 i件物品的体积是 <span class="hljs-keyword">vi</span>，价值是 <span class="hljs-keyword">wi</span>。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。<br>输入格式<br>第一行两个整数，<span class="hljs-keyword">N</span>，V，用空格隔开，分别表示物品数量和背包容积。<br>接下来有 <span class="hljs-keyword">N</span>行，每行两个整数 <span class="hljs-keyword">vi</span>,<span class="hljs-keyword">wi</span>，用空格隔开，分别表示第 i件物品的体积和价值。<br>输出格式<br>输出一个整数，表示最大价值。<br></code></pre></td></tr></table></figure>

</li>
<li><p>二维代码（朴素）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> w[N], v[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)   <span class="hljs-comment">//f[0][0~m] ==</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++)<br>        &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>        &#125;<br>    cout &lt;&lt; f[n][m];  <br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>优化为一维代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> w[N], v[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)   <span class="hljs-comment">//f[0][0~m] == 0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125;<br>    cout &lt;&lt; f[m];<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1010</span>)<br>f = [<span class="hljs-number">0</span>] * N<br>w = [<span class="hljs-number">0</span>] * N<br>v = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        v[i], w[i] = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, v[i]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i])<br>    <span class="hljs-built_in">print</span>(f[m])<br>            <br></code></pre></td></tr></table></figure>



<ul>
<li>优化过程</li>
</ul>
<p>1、将二维数组f降为一维，减去的是第i层，因为i层的更新只与i-1层有关，第i层更新直接把第i-1层覆盖就行了</p>
<p>2、<code> f[i][j] = f[i - 1][j];</code>	可以直接去掉，因为f[j] &#x3D; f[j], 即第i层的f[j]一开始就是等于第i-1层的f[j]的</p>
<p>3、0~v[i]都不会进入if语句，那么让j直接从v[i]开始就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++)<br>&#123;<br>	<span class="hljs-keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= m; j++)<br>&#123;<br>	f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>&#125;    <br></code></pre></td></tr></table></figure>

<p>但如果j是升序的话，j-v[i] &lt;&#x3D; j会找到第i层循环已经更新了的f[j - v[i]]（&#x3D;&#x3D;降维后是覆盖式写入，升序，则小于j的部分全部都被覆盖成了第i层的数据，这时再去找小于j的数据找的就是第i层的数据&#x3D;&#x3D;）, 但要求我们找到第i-1层的f[j - v[i]],所以我们将j倒序就行了</p>
<p>再次优化后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--)<br>&#123;<br>	f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="4-1-2完全背包问题"><a href="#4-1-2完全背包问题" class="headerlink" title="4.1.2完全背包问题"></a>4.1.2完全背包问题</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vim">有 <span class="hljs-keyword">N</span>种物品和一个容量是 V的背包，每种物品都有无限件可用。<br>第 i种物品的体积是 <span class="hljs-keyword">vi</span>，价值是 <span class="hljs-keyword">wi</span>。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。<br><br>输入格式<br>第一行两个整数，<span class="hljs-keyword">N</span>，V，用空格隔开，分别表示物品种数和背包容积。<br>接下来有 <span class="hljs-keyword">N</span>行，每行两个整数 <span class="hljs-keyword">vi</span>,<span class="hljs-keyword">wi</span>，用空格隔开，分别表示第 i种物品的体积和价值。<br><br>输出格式<br>输出一个整数，表示最大价值。<br><br>数据范围<br><span class="hljs-number">0</span>&lt;<span class="hljs-keyword">N</span>,V≤<span class="hljs-number">1000</span><br><span class="hljs-number">0</span>&lt;<span class="hljs-keyword">vi</span>,<span class="hljs-keyword">wi</span>≤<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure>



<ul>
<li>思路：</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>二维朴素算法（不一定行）三次方级的时间复杂度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> w[N], v[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k*v[i] &lt;= j; k++)<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k*v[i]] + k*w[i]);<br>    <br>    cout &lt;&lt; f[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>优化</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%85%AC%E5%BC%8F%E4%BC%98%E5%8C%96%E6%8E%A8%E5%AF%BC.png" srcset="/img/loading.gif" lazyload></p>
<p>这就把带k的循环转换成了只含i、j的循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> w[N], v[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++)<br>        &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);<br>        &#125;<br>    cout &lt;&lt; f[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>再把上述程序优化为一维的（与01背包问题的区别就是完全背包的j是升序的）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> w[N], v[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= m; j++)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>    cout &lt;&lt; f[m];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;注意：&#x3D;&#x3D; 完全背包问题不同于01背包问题，完全背包问题优化后恰好要找的就是第i层的j - v[i]，因此 j 升序</p>
<h4 id="4-1-3-多重背包问题"><a href="#4-1-3-多重背包问题" class="headerlink" title="4.1.3 多重背包问题"></a>4.1.3 多重背包问题</h4><ul>
<li>思路</li>
</ul>
<p>分析过程与完全背包问题类似：状态方程变为： f[i][j] &#x3D;max( f[i - 1][j - k * v[i]] + k*w[i] )  (k &lt;&#x3D; s[i])</p>
<ul>
<li>朴素二维代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">101</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> w[N], s[N], v[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; j &gt;= v[i]*k; k++)<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i<span class="hljs-number">-1</span>][j-k*v[i]]+w[i]*k);<br>    cout&lt;&lt; f[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>题目</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">有 <span class="hljs-keyword">N</span>种物品和一个容量是 V的背包。<br>第 i种物品最多有 si件，每件体积是 <span class="hljs-keyword">vi</span>，价值是 <span class="hljs-keyword">wi</span>。<br>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。<br><br>输入格式<br>第一行两个整数，<span class="hljs-keyword">N</span>，V，用空格隔开，分别表示物品种数和背包容积。<br>接下来有 <span class="hljs-keyword">N</span>行，每行三个整数 <span class="hljs-keyword">vi</span>,<span class="hljs-keyword">wi</span>,si，用空格隔开，分别表示第 i种物品的体积、价值和数量。<br><br>输出格式<br>输出一个整数，表示最大价值。<br><br>数据范围<br><span class="hljs-number">0</span>&lt;<span class="hljs-keyword">N</span>≤<span class="hljs-number">1000</span><br><span class="hljs-number">0</span>&lt;V≤<span class="hljs-number">2000</span><br><span class="hljs-number">0</span>&lt;<span class="hljs-keyword">vi</span>,<span class="hljs-keyword">wi</span>,si≤<span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure>

<p><strong>若用朴素算法，时间复杂度是NVS， 10的九次方级别，肯定会超时，所以就用二进制的思想进行优化</strong></p>
<ul>
<li>二进制优化(看题目的数据范围)</li>
</ul>
<p>不能用完全背包问题的思路来优化，得用二进制优化：<br>假设i号物品有200个， 则可以将它们分为 1、2，4，8，16、32、64、73，对这些分组进行任意组合（每个分组只能选一次）即可以表示0~200范围内的任意数字。所以我们的优化过程就是将 s &#x3D; k的一种物品，把k拆开为t份，这t份每份都看作一种新物种。对所有输入的物体都进行这种操作，然后有最终得到的v、w数组，对它们进行01背包问题的分析就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">11010</span>, M = <span class="hljs-number">2010</span>; <span class="hljs-comment">//M是背包最大容量，N是物品总数</span><br><span class="hljs-comment">//假设一种物品有2000个，则可以将它打包成log(2000)份，将他们看成不同的种类</span><br><span class="hljs-comment">//N = 原始物品种数 * log(s[i]max) 即N = 1000*log(2000)</span><br><span class="hljs-type">int</span> w[N], v[N]; <span class="hljs-comment">//不用s数组，因为在输入数据的时候就直接将物体拆分了</span><br><span class="hljs-type">int</span> f[M];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">//拆分后的物品下标</span><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;  <span class="hljs-comment">//二进制优化，从1开始</span><br>        <span class="hljs-keyword">while</span>(k &lt;= s)<br>        &#123;<br>            cnt++;<br>            v[cnt] = a*k;  <span class="hljs-comment">//体积*被分得的物品总数</span><br>            w[cnt] = b*k;<br>            s -= k;        <span class="hljs-comment">//从总数s种减去k个</span><br>            k *= <span class="hljs-number">2</span>;          <span class="hljs-comment">//二进制，乘二继续循环</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>)      <span class="hljs-comment">//若总数s还有剩余</span><br>        &#123;<br>            cnt ++; <br>            v[cnt] = a*s;  <span class="hljs-comment">//体积*剩余个数</span><br>            w[cnt] = b*s;<br>        &#125;<br>    &#125;<br>    n = cnt;     <span class="hljs-comment">//将n更新为新的“物种”数量</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)   <span class="hljs-comment">//对初始化得到的新的物种分类进行01背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>    <br>    cout &lt;&lt; f[m];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-1-4-分组背包问题"><a href="#4-1-4-分组背包问题" class="headerlink" title="4.1.4 分组背包问题"></a>4.1.4 分组背包问题</h4><ul>
<li><p>状态转移方程：f[i][j] &#x3D; max( f[i-1][j], f[i-1][j - v[i][k]] + w[i][k] )</p>
</li>
<li><p>题目</p>
</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">有 <span class="hljs-built_in">N</span>组物品和一个容量是 V的背包。<br>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i是组号，j是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。<br>输出最大价值。<br>输入格式<br>第一行有两个整数 <span class="hljs-built_in">N</span>，V，用空格隔开，分别表示物品组数和背包容量。<br>接下来有 <span class="hljs-built_in">N</span>组数据：<br>每组数据第一行有一个整数 Si，表示第 i个物品组的物品数量；每组数据接下来有 Si行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i个物品组的第 j个物品的体积和价值；<br>输出格式<br>输出一个整数，表示最大价值。<br><br>数据范围<br><span class="hljs-number">0</span>&lt;<span class="hljs-built_in">N</span>,V≤<span class="hljs-number">100</span><br><span class="hljs-number">0</span>&lt;Si≤<span class="hljs-number">100</span><br><span class="hljs-number">0</span>&lt;vij,wij≤<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>



<ul>
<li>优化代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> f[N], s[N];<br><span class="hljs-type">int</span> w[N][N], v[N][N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s[i]; j++)<br>        &#123;<br>            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j--)  <span class="hljs-comment">//逆序，因为要选择未更新的i-1层来更新第i层,有因为v[i][k]不确定，所以条件不能写成j &gt;= v[i][k]</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k++)   <span class="hljs-comment">//不可以写成for(int k = 1; k &lt;= s[i] &amp;&amp; j &gt;= v[i][k]; k++),因为这样一旦不满足j &gt;= v[i][k]循环就会结束</span><br>                <span class="hljs-keyword">if</span>(j &gt;= v[i][k])             <span class="hljs-comment">//但下一个v[i][k]可能又满足条件了，这就导致可能会漏一些情况，本质原因是v[i][k]不是线性变化的</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[m];<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">110</span>)<br>f = [<span class="hljs-number">0</span>] * N<br>s = [<span class="hljs-number">0</span>] * N<br>w = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>v = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        s[i] = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, s[i]+<span class="hljs-number">1</span>):<br>            v[i][j], w[i][j] = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            k = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> k &lt;= s[i]:<br>                <span class="hljs-keyword">if</span> v[i][k] &lt;= j:<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j-v[i][k]] + w[i][k])<br>                k += <span class="hljs-number">1</span> <br>    <span class="hljs-built_in">print</span>(f[m])<br></code></pre></td></tr></table></figure>





<h3 id="4-2、线性DP问题"><a href="#4-2、线性DP问题" class="headerlink" title="4.2、线性DP问题"></a>4.2、线性DP问题</h3><p>若要用memset给整型数组赋值，只能赋-1、0、0x3f3f3f3f,其他的数字都会出错</p>
<h4 id="4-2-1数字三角形"><a href="#4-2-1数字三角形" class="headerlink" title="4.2.1数字三角形"></a>4.2.1数字三角形</h4><ul>
<li>分析</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7DP.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N][N];   <span class="hljs-comment">//储存状态值</span><br><span class="hljs-type">int</span> a[N][N];  <span class="hljs-comment">//储存三角形值</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>            cin &gt;&gt; a[i][j];<br>            <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)      <span class="hljs-comment">//初始化f数组，初始化未-INF是为了比较max时方便更新最大值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i<span class="hljs-number">+1</span>; j++)  <span class="hljs-comment">//注意边界，要让f越界时的值都是-INF</span><br>            f[i][j] = -INF;<br>            <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)     <span class="hljs-comment">//从第二层开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j  = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]) + a[i][j];   <span class="hljs-comment">//状态转移方程</span><br>    <br>    <span class="hljs-type">int</span> ans = -INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans = <span class="hljs-built_in">max</span>(ans, f[n][i]);   <span class="hljs-comment">//找最后一层的最大值</span><br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>注意数字三角形可能是负数，因此对dp数组应该初始化为负无穷，这样才可以正确讨论边界情况</p>
<ul>
<li>优化代码（只用一个数组）</li>
</ul>
<p>因为实际上状态转移方程中的 + a[i][j] 只与本层有关，与更新了的上一层无关，所以完全没必要再开一个数组存储数字信息，因为更新完这层的f后，这层的数字信息就没有了，被覆盖掉也没事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N][N];   <span class="hljs-comment">//储存状态值</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)      <span class="hljs-comment">//初始化f数组，初始化未-INF是为了比较max时方便更新最大值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i<span class="hljs-number">+1</span>; j++)<br>            f[i][j] = -INF;<br>            <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>            cin &gt;&gt; f[i][j];<br>            <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)     <span class="hljs-comment">//从第二层开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j  = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]) + f[i][j];   <span class="hljs-comment">//状态转移方程</span><br>    <br>    <span class="hljs-type">int</span> ans = -INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans = <span class="hljs-built_in">max</span>(ans, f[n][i]);   <span class="hljs-comment">//找最后一层的最大值</span><br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>优化代码（从下往上走）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N][N];   <span class="hljs-comment">//储存状态值</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)      <span class="hljs-comment">//完全不用初始化f，因为从下往上的话f不可能越界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>            cin &gt;&gt; f[i][j];<br>            <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">1</span>; i--)     <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j  = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], f[i + <span class="hljs-number">1</span>][j]) + f[i][j];   <span class="hljs-comment">//状态转移方程</span><br><br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="4-2-2最长上升子序列"><a href="#4-2-2最长上升子序列" class="headerlink" title="4.2.2最长上升子序列"></a>4.2.2最长上升子序列</h4><ul>
<li><p>DP问题的时间复杂度主要看状态转移方程</p>
</li>
<li><p>如果想记录或输出DP问题的状态转移过程|方案选择，则要用一个数组记录每次状态转移的来源</p>
</li>
<li><p>分析：</p>
</li>
</ul>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.png" srcset="/img/loading.gif" lazyload></p>
<p>对f进行遍历，每次都会再次&#x3D;&#x3D;从前往后&#x3D;&#x3D;看看a数组有没有满足升序的，如果有并且比之前的子序列都要长的话就会对f进行更新。</p>
<ul>
<li>O(n^2)代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> f[N];   <span class="hljs-comment">//存该位置的最长上升子序列长度</span><br><span class="hljs-type">int</span> g[N];   <span class="hljs-comment">//存该位置的状态变化来源于哪个位置</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; a[i];<br>        f[i] = <span class="hljs-number">1</span>;              <span class="hljs-comment">//初始化f，每个位置一开始的长度都只是1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>            <span class="hljs-keyword">if</span>(a[j] &lt; a[i] &amp;&amp; f[i] &lt; f[j] + <span class="hljs-number">1</span>)<br>            &#123;<br>                f[i] = f[j] + <span class="hljs-number">1</span>;<br>                g[i] = j;      <span class="hljs-comment">//用g数组储存变化来源</span><br>            &#125;<br>    &#125;<br>            <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)   <span class="hljs-comment">//找出储存最大值的下标，方便遍历</span><br>        <span class="hljs-keyword">if</span>(f[k] &lt; f[i])<br>            k = i;<br>    cout &lt;&lt; f[k] &lt;&lt; endl;<br>    <br>    <span class="hljs-type">int</span> len = f[k];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        cout &lt;&lt; a[k] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        k = g[k];<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1010</span>)<br>f = [<span class="hljs-number">1</span>] * N<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    x = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> x[i] &gt; x[j]:<br>                f[i] = <span class="hljs-built_in">max</span>(f[j]+<span class="hljs-number">1</span>, f[i])<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        res = <span class="hljs-built_in">max</span>(res, f[i])<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<h4 id="4-2-3-最长公共子序列"><a href="#4-2-3-最长公共子序列" class="headerlink" title="4.2.3 最长公共子序列"></a>4.2.3 最长公共子序列</h4><p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20241028205042454.png" srcset="/img/loading.gif" lazyload alt="image-20241028205042454"></p>
<p>f[i-1][j-1] + 1: 一定选a的第i个和b的第j个的情况</p>
<p>f[i][j-1]: 选a的前i个和b的前j-1个的情况</p>
<p> f[i-1][j]: 选a的前i-1个和b的前j个的情况</p>
<p>f[i-1][j-1]: 不选a的第i个和b的第j个的情况</p>
<p>可以看出第四种情况是包含在第二、三种情况当中的，在求最大值的情况下，包含的情况是允许的，所以可以只讨论前三种状态之间的转移</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        cin &gt;&gt; b[j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);   <span class="hljs-comment">//一定选a的第i个和b的第j个的情况一定得是a的第i个和b的第j个相同</span><br>        &#125;<br>        <br>    cout &lt;&lt; dp[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1010</span>)<br>f = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    a = <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">input</span>()<br>    b = <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> a[i] == b[j]:<br>                f[i][j] = f[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> <br>            <span class="hljs-keyword">else</span>:<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i-<span class="hljs-number">1</span>][j], f[i][j-<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(f[n][m])<br>     <br></code></pre></td></tr></table></figure>



<h4 id="4-2-3最短编辑距离"><a href="#4-2-3最短编辑距离" class="headerlink" title="4.2.3最短编辑距离"></a>4.2.3最短编辑距离</h4><p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20241029231912685.png" srcset="/img/loading.gif" lazyload alt="image-20241029231912685"></p>
<p>集合f[i][j]表示将a[1~i]变成b[1~j]的最少编辑次数</p>
<p>状态转移方程以最后一次编辑操作的方式分类，分为三类：</p>
<ul>
<li>最后一次操作是删除，则要求a[1~i-1]与b[1~j]相同，所以总次数就是将a[1~i-1]变为b[j]的次数加1</li>
<li>最后一次操作是增加，则要求a[1~i]与b[1~j-1]相同，所以总次数就是将a[1~i]变为b[1~i-1]的次数加1</li>
<li>最后一次操作是更改，则要求a[1~i-1]与b[1~j-1]相同，所以总次数就是将a[1~i-1]变为b[1~j-1]的次数加1或0（当a[i]与b[j]相同时加0）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        cin &gt;&gt; b[i];<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)      <span class="hljs-comment">//注意要初始化,a[0]要变成b[j],则一定是增加j次</span><br>        dp[<span class="hljs-number">0</span>][i] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>    cout &lt;&lt; dp[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-3、区间dp"><a href="#4-3、区间dp" class="headerlink" title="4.3、区间dp"></a>4.3、区间dp</h3><p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20241103183207701.png" srcset="/img/loading.gif" lazyload alt="&#x3D;image-20241103183207701&#x3D;"></p>
<p>状态转移方程：dp[i][j] &#x3D; min (dp[i][j], dp[i][k] + dp[k+1][r] + s[r] - s[l - 1])</p>
<p>以最后一次合并哪两个区间划分集合（最后一步合并i~k与k+1~j，并加上最后一步的代价，用前缀和数组s记录，一减就可以得出区间所有石堆的质量和，不用再循环）</p>
<ul>
<li>上代码！！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> s[N];    <span class="hljs-comment">//前缀和数组</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; s[i];<br>        s[i] += s[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)  <span class="hljs-comment">//枚举区间长度，从2开始是因为当区间长度为1时，有dp[i][i],将第i堆与第i堆石子合并根本不需要代价，dp[i][i]=0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> l = i, r = i + len - <span class="hljs-number">1</span>;<br>            dp[l][r] = <span class="hljs-number">1e9</span>;           <span class="hljs-comment">//要初始化一个很大的值，不然的化一直是0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i; k &lt; r; k++)<br>                dp[l][r] = <span class="hljs-built_in">min</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r] + s[r] - s[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    <br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][n];<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">310</span>)<br>INF = <span class="hljs-built_in">int</span>(<span class="hljs-number">0x3f3f3f3f</span>)<br>f = [[<span class="hljs-number">0</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>s = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    a = [<span class="hljs-number">0</span>] + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        s[i] = s[i-<span class="hljs-number">1</span>] + a[i]<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i + <span class="hljs-built_in">len</span> -<span class="hljs-number">1</span> &lt;= n:<br>            l, r = i, i + <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span><br>            f[l][r] = INF<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r):<br>                f[l][r] = <span class="hljs-built_in">min</span>(f[l][r], f[l][k] + f[k+<span class="hljs-number">1</span>][r] + s[r] - s[l-<span class="hljs-number">1</span>])<br>            i += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(f[<span class="hljs-number">1</span>][n])<br></code></pre></td></tr></table></figure>



<h3 id="4-4计数dp"><a href="#4-4计数dp" class="headerlink" title="4.4计数dp"></a>4.4计数dp</h3><p><strong>思路</strong>：把1,2,3, … n分别看做n个物体的体积(v[i] &#x3D; i)，这n个物体均无使用次数限制，问恰好能装满总体积为n的背包的总方案数（&#x3D;&#x3D;完全背包&#x3D;&#x3D;问题变形）</p>
<p>**dp数组：**dp[i][j]表示只用1，2，……，i能够有多少种方案组成数字j</p>
<p><strong>题型：</strong></p>
<ul>
<li>求方案数最大值<ul>
<li>dp[j] &#x3D; max(dp[j], dp[j-i])</li>
</ul>
</li>
<li>求总方案数<ul>
<li>dp[j] &#x3D; dp[j] + dp[j-i]</li>
</ul>
</li>
</ul>
<p><strong>初值问题</strong>：<br>求最大值时，当都不选时，价值显然是 0<br>而求方案数时，当都不选时，方案数是 1（即前 i 个物品都不选的情况也是一种方案），所以需要初始化为 1<br>即：for (int i &#x3D; 0; i &lt;&#x3D; n; i ++) f[i][0] &#x3D; 1;<br>等价变形后： f[0] &#x3D; 1</p>
<h3 id="4-5、数位统计dp"><a href="#4-5、数位统计dp" class="headerlink" title="4.5、数位统计dp"></a>4.5、数位统计dp</h3><p>先看不用dp怎么做？</p>
<ul>
<li><p>首先参考前缀和的思路，用一个count(a， x)算所有0~a的数中每一位是x的个数，然后算a~b的数中每一位是x的个数就是用</p>
<p>  count(b, x) - count(a-1, x)</p>
</li>
<li><p>然后再考虑怎么设计count函数，假设有7位数abcdefg，我们先分别考虑每一位是x的情况，然后再加起来</p>
</li>
</ul>
<p>假设现在考虑第4位是x的数的个数：</p>
<ul>
<li>首先是000x???~(abc-1)x???，一共有(abc-1)*1000个</li>
<li>然后是abcx???后面的数的情况<ul>
<li>若x&gt;d，则abcx???一定大于abcdefg，这种情况没有</li>
<li>若x&#x3D;&#x3D;d，则abcx000~abcxefg均满足，这种情况有efg+1个</li>
<li>若x&lt;d，则abcx000~abcx999，这种情况有1000个</li>
</ul>
</li>
<li>特别的情况：<ul>
<li>当考虑的x是0时，首先不能在第一位，其次x之前的位不可以全部是0（全是0的话这一位就不存在了，000 0 efg）</li>
<li>当考虑x是第一位的情况时，不用考虑    000x???~(abc-1)x???这种情况</li>
</ul>
</li>
</ul>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>   <span class="hljs-comment">//个十百，分别对应123位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pow10</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>    <span class="hljs-comment">// 返回10的i次方</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i--)<br>        res *= <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; num, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">//返回数组下标第r~l的数字的大小（r是高位）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = r; i &gt;= l; i--)  <span class="hljs-comment">//累乘要从数字的高位开始，数字的高位在数组中的下标是更大的</span><br>        res = res*<span class="hljs-number">10</span> + num[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span>   <span class="hljs-comment">//返回1~n的数字有多少个x</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; num;<br>    <span class="hljs-keyword">while</span> (n)            <span class="hljs-comment">//将数字存入数组，注意：下标从小到大依次存放低位到高位数字</span><br>    &#123;<br>        num.<span class="hljs-built_in">push_back</span>(n%<span class="hljs-number">10</span>);<br>        n/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    n = num.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span> - !x; i &gt;= <span class="hljs-number">0</span>; i--)  <span class="hljs-comment">//从高位数字开始枚举,i要减一变为数组下标，-!x意思是</span><br>    <span class="hljs-comment">//当x为0的时候不考虑0在最高位的情况；注意i是数组下标！！</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; n<span class="hljs-number">-1</span>)   <span class="hljs-comment">//考虑第一位的x时不需要讨论这种情况</span><br>        &#123;<br>            res += <span class="hljs-built_in">get</span>(num, i<span class="hljs-number">+1</span>, n<span class="hljs-number">-1</span>) * <span class="hljs-built_in">pow10</span>(i); <span class="hljs-comment">//i是实际位数-1的版本，因此用10的i次方刚刚好</span><br>            <span class="hljs-keyword">if</span>(!x) res -= <span class="hljs-built_in">pow10</span>(i);    <span class="hljs-comment">//考虑x是0的时候要排除x的前面全是0的情况</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(x == num[i]) res += <span class="hljs-built_in">get</span>(num, <span class="hljs-number">0</span>, i<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; num[i]) res += <span class="hljs-built_in">pow10</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; a &gt;&gt; b, a)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-built_in">swap</span>(a, b);  <span class="hljs-comment">//保持a始终是最小的</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++)<br>            cout &lt;&lt; <span class="hljs-built_in">count</span>(b, i) - <span class="hljs-built_in">count</span>(a<span class="hljs-number">-1</span>, i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>容易弄错的是数组的下标和真实的数的位数的对应关系</p>
<h3 id="4-6、状态压缩dp"><a href="#4-6、状态压缩dp" class="headerlink" title="4.6、状态压缩dp"></a>4.6、状态压缩dp</h3><h4 id="4-6-1、梦想"><a href="#4-6-1、梦想" class="headerlink" title="4.6.1、梦想"></a>4.6.1、梦想</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">求把 N×M的棋盘分割成若干个 <span class="hljs-number">1</span>×<span class="hljs-number">2</span>的长方形，有多少种方案。<br>例如当 N<span class="hljs-operator">=</span><span class="hljs-number">2</span>，M<span class="hljs-operator">=</span><span class="hljs-number">4</span>时，共有 <span class="hljs-number">5</span>种方案。当 N<span class="hljs-operator">=</span><span class="hljs-number">2</span>，M<span class="hljs-operator">=</span><span class="hljs-number">3</span>时，共有 <span class="hljs-number">3</span>种方案。<br></code></pre></td></tr></table></figure>



<p>思路：摆放方块的时候，先放横着的，再放竖着的。总方案数等于只放横着的小方块的合法方案数。</p>
<p>如何判断，当前方案数是否合法？ 所有剩余位置能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块需要是偶数个。</p>
<p>状态压缩的dp：用一个N位的二进制数，每一位表示一个物品，0&#x2F;1表示不同的状态。</p>
<p>状态数组f[i][j]：表示已经将前 i -1 列摆好，且从第i−1列，伸出到第 i列的状态是 j的所有方案。其中j是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。</p>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp.png" srcset="/img/loading.gif" lazyload></p>
<p>状态转移方程：f[i][j] &#x3D; sum(f[i-1][k]) , 其中k是第i-2层伸出到第i-1层的状态，k要满足一定的条件使得方块摆放的情况合法： 1、情况k和j不能有同样的层是1，即k&amp;j&#x3D;&#x3D;0<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20250213212731368.png" srcset="/img/loading.gif" lazyload alt="image-20250213212731368" style="zoom:33%;" /></p>
<p>2、第i-1层的连续的0必须有偶数个，这由i-2层伸到第i-1层的方块和第i-1层摆放的方块共同决定，即st[j | k] &#x3D;&#x3D; True</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">12</span>)<br>M = <span class="hljs-number">1</span> &lt;&lt; N<br>state = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M)] <span class="hljs-comment"># state[a][b]记录的是第i列状态为a和第i-1列状态为b时是否“合理”</span><br>st = [<span class="hljs-literal">True</span>] * M         <span class="hljs-comment"># st[j]记录状态j的连续0是否为偶数个</span><br>f = [[<span class="hljs-number">0</span>] * M <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]  <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">while</span> n | m:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):      <span class="hljs-comment"># 初始化st数组</span><br>            j = <span class="hljs-number">0</span><br>            cnt = <span class="hljs-number">0</span><br>            is_valid = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">while</span> j &lt; n:<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j) &amp; <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> cnt % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                        is_valid = <span class="hljs-literal">False</span><br>                        <span class="hljs-keyword">break</span><br>                    cnt = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    cnt += <span class="hljs-number">1</span> <br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                is_valid = <span class="hljs-literal">False</span><br>            st[i] = is_valid<br>    <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):     <span class="hljs-comment"># 初始化state数组</span><br>            state[i].clear()      <span class="hljs-comment"># 清除上一个m，n留下的痕迹</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):<br>                <span class="hljs-keyword">if</span> (i &amp; j) == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> st[i | j] == <span class="hljs-literal">True</span>: <br>                    state[i].append(j)<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, N):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, M):<br>                f[i][j] = <span class="hljs-number">0</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> state[j]:     <span class="hljs-comment"># 摆放方式必须合法才能加上去</span><br>                    f[i][j] += f[i-<span class="hljs-number">1</span>][k]<br>        <span class="hljs-built_in">print</span>(f[m][<span class="hljs-number">0</span>])<br>        n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br></code></pre></td></tr></table></figure>





<h4 id="4-6-2、哈密顿路径（旅行商问题）"><a href="#4-6-2、哈密顿路径（旅行商问题）" class="headerlink" title="4.6.2、哈密顿路径（旅行商问题）"></a>4.6.2、哈密顿路径（旅行商问题）</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一张 <span class="hljs-built_in">n</span>个点的带权无向图，点从 <span class="hljs-number">0</span>∼<span class="hljs-built_in">n</span>−<span class="hljs-number">1</span>标号，求起点 <span class="hljs-number">0</span>到终点 <span class="hljs-built_in">n</span>−<span class="hljs-number">1</span>的最短 Hamilton 路径。<br>Hamilton 路径的定义是从 <span class="hljs-number">0</span>到 <span class="hljs-built_in">n</span>−<span class="hljs-number">1</span>不重不漏地经过每个点恰好一次。<br></code></pre></td></tr></table></figure>

<p>和最短路的区别是，哈密顿路径要求所有的点都要经过</p>
<p>假设起点0，终点5，而终点前要求经过点4，则有：</p>
<p>0—1—2—3—4       0—1—3—2—4      0—2—1—3—4      0—2—3—1—4     0—3—2—1—4  0—3—1—2—4</p>
<p>这六种情况，然后4-5的距离不变，则最短距离就是上述六种情况的最短距离加上4-5的距离。每一种路径的长度只于经过的点和终点有关，因此我们定义状态方程f[i][j]：经过的点为i（用二进制数表示经过的点，经过0、1、3表示为1011），终点为j的路径的长度。</p>
<p>状态转移方程：f[i][j] &#x3D; min(f[i][j], f[i-(1&lt;&lt; j)][k]+w[k][j]),   也就是i到j的最短距离取决于i到k（除了j以外的所有点）的最短距离加上k到j的距离。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">21</span>)<br>M = <span class="hljs-number">1</span> &lt;&lt; N<br>w = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>f = [[<span class="hljs-number">0x3f3f3f3f</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M)]<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        w[i] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>       <span class="hljs-comment"># 起点是0号点状态i为1，终点j也为0号点，距离为0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span> &lt;&lt; n):  <span class="hljs-comment"># 遍历每一种状态</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-comment"># 每个点都得试着当终点</span><br>            <span class="hljs-keyword">if</span> i &gt;&gt; j &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>:   <span class="hljs-comment"># 终点必须得包含在路径中才合法</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):   <span class="hljs-comment"># 每个点（除了j）都要试着当终点的前一个点</span><br>                    <span class="hljs-keyword">if</span> i &gt;&gt; k &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>:   <span class="hljs-comment"># 此时k必须包含在路径中</span><br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i-(<span class="hljs-number">1</span>&lt;&lt;j)][k]+w[k][j])<br>       <span class="hljs-comment"># 原本的路径一定含有j，但以k为终点前一点的路径不能含j，所以要i-(1&lt;&lt;j)</span><br>    <span class="hljs-built_in">print</span>(f[(<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>])<br>    <br></code></pre></td></tr></table></figure>



<h3 id="4-7-树状dp"><a href="#4-7-树状dp" class="headerlink" title="4.7 树状dp"></a>4.7 树状dp</h3><p><strong>没有上司的舞会</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">Ural 大学有 <span class="hljs-built_in">N</span>名职员，编号为 <span class="hljs-number">1</span>∼<span class="hljs-built_in">N</span>。<br>他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。<br>每个职员有一个快乐指数，用整数 Hi给出，其中 <span class="hljs-number">1</span>≤i≤<span class="hljs-built_in">N</span>。<br>现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。<br>在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。<br></code></pre></td></tr></table></figure>



<p>状态数组：f[i][0] 在以i为根节点的子树中选择并且不选i的幸福最大值</p>
<p>f[i][1]在以i为根节点的子树中选择并且选i的幸福最大值</p>
<p>状态转移： 根结点i不选，则i的子节点u可以选也可以不选，则f[i][0]+&#x3D;sum[max(f[u][1], f[u][0])]</p>
<p>根节点i选，则i的子节点一定不能选，f[i][1]+&#x3D;sum(f[u][0])</p>
<p>很明显要用到深度优先遍历，因为要先得到子节点的情况才能更新父节点的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">6010</span>)<br>happy = [<span class="hljs-number">0</span>] * N<br>f = [[<span class="hljs-number">0</span>]*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>h = [-<span class="hljs-number">1</span>] * N<br>e = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> * N<br>ne = [<span class="hljs-number">0</span>] * N * <span class="hljs-number">2</span><br>idx = <span class="hljs-number">0</span><br>has_father = [<span class="hljs-literal">False</span>] * N    <span class="hljs-comment"># 记录该结点是否有父节点</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">global</span> idx<br>    e[idx] = b<br>    ne[idx] = h[a]<br>    h[a] = idx<br>    idx += <span class="hljs-number">1</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>    f[root][<span class="hljs-number">1</span>] = happy[root]   <span class="hljs-comment"># 如果选了root结点，则要加上它的快乐值</span><br>    i = h[root]<br>    <span class="hljs-keyword">while</span> i != -<span class="hljs-number">1</span>:     <span class="hljs-comment"># 遍历直接子节点</span><br>        x = e[i]<br>        dfs(x)          <span class="hljs-comment"># 往下去更新子结点的情况</span><br>        f[root][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(f[x][<span class="hljs-number">1</span>], f[x][<span class="hljs-number">0</span>])  <span class="hljs-comment"># 状态转移</span><br>        f[root][<span class="hljs-number">1</span>] += f[x][<span class="hljs-number">0</span>] <br>        i = ne[i]<br>    <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        happy[i] = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        add(b, a)<br>        has_father[a] = <span class="hljs-literal">True</span><br>    <br>    root = <span class="hljs-number">0</span>       <span class="hljs-comment"># 找出根节点</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> has_father[i] == <span class="hljs-literal">False</span>:<br>            root = i <br>            <span class="hljs-keyword">break</span><br>    <br>    dfs(root)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">1</span>], f[root][<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure>



<h3 id="4-8-记忆化搜索"><a href="#4-8-记忆化搜索" class="headerlink" title="4.8 记忆化搜索"></a>4.8 记忆化搜索</h3><p><strong>滑雪</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个 R行 C列的矩阵，表示一个矩形网格滑雪场。<br>矩阵中第 i行第 j列的点表示滑雪场的第 i行第 j列区域的高度。<br>一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。<br>当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。<br>下面给出一个矩阵作为例子：<br><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span>5<br>16<span class="hljs-number"> 17 </span>18<span class="hljs-number"> 19 </span>6<br>15<span class="hljs-number"> 24 </span>25<span class="hljs-number"> 20 </span>7<br>14<span class="hljs-number"> 23 </span>22<span class="hljs-number"> 21 </span>8<br>13<span class="hljs-number"> 12 </span>11<span class="hljs-number"> 10 </span>9<br>在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。<br>在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25个区域。<br>现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。<br></code></pre></td></tr></table></figure>



<p>状态数组：f[i][j]表示以(i,j)为起点的最长路径</p>
<p>状态转移：f[i][j] &#x3D; max(f[i-1][j]+1, f[i-1][j-1]+1, f[i][j+1]+1, f[i+1][j+1]+1)  也就是上下左右的最长路径+1的最大值</p>
<p>思考：这道题其实可以和采花生这道题比较<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1017/">1015. 摘花生 - AcWing题库</a></p>
<p>采花生其实是类似于数字三角形的线性dp问题，它一个位置只能由上边或者左边的点移动得到，而滑雪这道题的一个位置可以从四个方向得到。区别在于采花生直接对每一个点进行遍历，dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-1]),dp[i-1][j]和dp[i][j-1]都已经是被求过的了（因为这两个先前点也是只能从已经遍历了的点得到的）；而滑雪则是f[i][j]&#x3D;max(f[i][j], dp(i-1 ,j), dp(i+1, j), dp(i, j-1),dp(i,j+1)),四个方向都不是直接拿f数组，因为这四个方向的f都是还没被确定的，就假如我要求f[2][2], 这时f[2][3]可能是还没被求的，因此要用dp函数去求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">310</span>)<br>h = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>f = [[-<span class="hljs-number">1</span>] * N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>dx = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>dy = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">x, y</span>):      <span class="hljs-comment"># 返回以x，y为起点的最长路径的长度</span><br>    <span class="hljs-keyword">if</span> f[x][y] != -<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> f[x][y]<br>    f[x][y] = <span class="hljs-number">1</span>     <span class="hljs-comment"># 初始化</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        xx = dx[i] + x <br>        yy = dy[i] + y<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; xx &lt;= n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt; yy &lt;= m <span class="hljs-keyword">and</span> h[xx][yy] &lt; h[x][y]:<br>            f[x][y] = <span class="hljs-built_in">max</span>(f[x][y], dp(xx, yy)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> f[x][y]<br>    <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        h[i] = [-<span class="hljs-number">1</span>] + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>            res = <span class="hljs-built_in">max</span>(res, dp(i, j))<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>





<h2 id="五、数学知识"><a href="#五、数学知识" class="headerlink" title="五、数学知识"></a>五、数学知识</h2><h3 id="5-1质数"><a href="#5-1质数" class="headerlink" title="5.1质数"></a>5.1质数</h3><h4 id="5-1-1-质数判定——试除法"><a href="#5-1-1-质数判定——试除法" class="headerlink" title="5.1.1 质数判定——试除法"></a>5.1.1 质数判定——试除法</h4><p>其实就算最简单的思路哈哈：先判断是否小于1，大于1的话再试除，条件优化为i^2&lt;n</p>
<p>为什么可以这样优化呢：因为假设d|n,则n&#x2F;d | n，例如6，2|6则3|6，那么只用枚举到较小的因子就行了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        i = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">while</span> i &lt;= n // i:     <span class="hljs-comment"># 条件不写成i*i&lt;n是因为i*i一旦大于整数的边界，就会溢出变成负数</span><br>            <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">while</span> n:<br>    n = n - <span class="hljs-number">1</span><br>    a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    res = check(a)<br>    <span class="hljs-keyword">if</span> res == <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Yes&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;No&#x27;</span>)<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-built_in">check</span>(a);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-1-2-分解质因数（整数唯一分解定理）"><a href="#5-1-2-分解质因数（整数唯一分解定理）" class="headerlink" title="5.1.2 分解质因数（整数唯一分解定理）"></a>5.1.2 分解质因数（整数唯一分解定理）</h4><p>就是去列举每一个满足条件的i，一旦整除，就去算它的次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">n</span>):<br>    i = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> i &lt;= n // i:            <span class="hljs-comment"># 仍然用这个方法优化</span><br>        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:            <br>            s = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> n % i == <span class="hljs-number">0</span>:     <span class="hljs-comment"># i能够整除n，则去算这个素因子i的次数</span><br>                n //= i<br>                s += <span class="hljs-number">1</span><br>            <span class="hljs-built_in">print</span>(i, s)<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span>:                    <span class="hljs-comment"># 最多只有一个质因子是大于sqrt(n)的，就是除完以后剩余的那个</span><br>        <span class="hljs-built_in">print</span>(n, <span class="hljs-number">1</span>)<br>        <br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">while</span> n:<br>    n -= <span class="hljs-number">1</span><br>    a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    divide(a)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure>

<p>要注意的是python中要想整数除整数出现c语言那样的向下取整，就得用&#x2F;&#x2F;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(a % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                a /= i;<br>                s ++;<br>            &#125;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-built_in">divide</span>(a);<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="5-1-3素数筛法"><a href="#5-1-3素数筛法" class="headerlink" title="5.1.3素数筛法"></a>5.1.3素数筛法</h4><p>输出n以内的所有素数</p>
<p><strong>线性筛法：</strong>  题解完美解答<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/5374176/">AcWing 868. 筛质数 - AcWing</a></p>
<p>就例如筛去6的过程，朴素的筛法是2*3和3*2都筛了一遍6，那不就重复筛去了吗，所以我们要避免这种情况，保证一个数都被它的最小质因子的倍数筛去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-number">1000010</span><br>prime = []<br>is_prime = [<span class="hljs-literal">True</span>]*N<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_prime</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> is_prime[i]:        <span class="hljs-comment"># 遍历到自己了还没被筛去，之后也不可能被筛去了，所以它一定是素数 </span><br>            prime.append(i)<br>        j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i * prime[j] &lt;= n:<br>            is_prime[i * prime[j]] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> i % prime[j] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(prime)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-built_in">print</span>(find_prime(n))<br>            <br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">bool</span> is_prime[N];<br><span class="hljs-type">int</span> prime[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(is_prime[i] == <span class="hljs-literal">false</span>) prime[cnt++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] * i &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> t = prime[j] * i;<br>            is_prime[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="5-2-约数"><a href="#5-2-约数" class="headerlink" title="5.2 约数"></a>5.2 约数</h3><h4 id="5-2-1-试除法求约数"><a href="#5-2-1-试除法求约数" class="headerlink" title="5.2.1 试除法求约数"></a>5.2.1 试除法求约数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">n</span>):<br>    f = []<br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i &lt;= n / i:              <span class="hljs-comment"># 迭代到n/i即可</span><br>        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:<br>            f.append(i)<br>            <span class="hljs-keyword">if</span> n // i != i:        <span class="hljs-comment"># i是约数的话，n/i也一定是约数，这里的条件是为了防止n是平方数</span><br>                f.append(n // i)<br>        i += <span class="hljs-number">1</span><br>    f.sort()<br>    <span class="hljs-keyword">return</span> f<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>        f = divide(a)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> f:<br>            <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)   <span class="hljs-comment"># 注意打印格式</span><br>        <span class="hljs-built_in">print</span>()<br>        n -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(i != n / i) res.<span class="hljs-built_in">push_back</span>(n / i);<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">divide</span>(a);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : res) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-2-2约数个数"><a href="#5-2-2约数个数" class="headerlink" title="5.2.2约数个数"></a>5.2.2约数个数</h4><p><strong>公式</strong>：$res &#x3D; (\alpha_1+1)<em>…</em>(\alpha_n+1)$，其中，$\alpha_i$为这个数的唯一分解式对应每一项的指数</p>
<p><strong>证明</strong>：略</p>
<p>题目:给定 n个正整数 ai，请你输出这些数的乘积的约数个数，答案对 1e9+7 取模。</p>
<p>实际上就是分别将每一个ai分解了，再把它们相同项的指数加起来，就是它们的乘积x分解后每一项的指数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;&#125;                                <span class="hljs-comment"># 创建一个空字典</span><br>Mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        j = <span class="hljs-number">2</span><br>        x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>        <span class="hljs-keyword">while</span> j &lt;= x // j:  <br>            <span class="hljs-keyword">while</span> x % j == <span class="hljs-number">0</span>:           <span class="hljs-comment"># 分解j出来，并算j的次数</span><br>                x //= j<br>                <span class="hljs-keyword">if</span> j <span class="hljs-keyword">in</span> dic:            <br>                    dic[j] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dic[j] = <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:                     <br>            <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> dic:<br>                dic[x] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                dic[x] = <span class="hljs-number">1</span><br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> dic.items():<br>        res = (res * (item[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) % Mod<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%d&quot;</span>%res)<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(a % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                a /= i;<br>                primes[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1</span>)<br>            primes[a]++;<br>    &#125;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : primes) res *= (x.second + <span class="hljs-number">1</span>) % mod;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-2-3-约数之和"><a href="#5-2-3-约数之和" class="headerlink" title="5.2.3 约数之和"></a>5.2.3 约数之和</h4><p><strong>公式：</strong><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20241207160134924.png" srcset="/img/loading.gif" lazyload alt="image-20241207160134924" style="zoom:50%;" /></p>
<p>实际上相较于求约数个数的模板，这个模板就算多了一步求和，用秦九昭公式，t &#x3D; 1，t &#x3D; t *p+1&#x3D;p+1,  t &#x3D; t * p + 1 &#x3D; p^2+p+1…….</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">Mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>prime = &#123;&#125;<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>        j = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">while</span> j &lt;= x // j:<br>            <span class="hljs-keyword">while</span> x % j == <span class="hljs-number">0</span>:<br>                x //= j<br>                <span class="hljs-keyword">if</span> j <span class="hljs-keyword">in</span> prime:<br>                    prime[j] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    prime[j] = <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> prime:<br>                prime[x] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                prime[x] = <span class="hljs-number">1</span><br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> p, alpha <span class="hljs-keyword">in</span> prime.items():<br>        t = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> alpha:<br>            t = (p * t + <span class="hljs-number">1</span> ) % Mod<br>            alpha -= <span class="hljs-number">1</span><br>        res = res * t % Mod<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; prime;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(a % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                a /= i;<br>                prime[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            prime[a]++;<br>        &#125;<br>    &#125;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : prime)<br>    &#123;<br>        LL t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(x.second--) t = (t * x.first + <span class="hljs-number">1</span>) % Mod;<br>        res = res * t % Mod;<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-2-4求最大公因数"><a href="#5-2-4求最大公因数" class="headerlink" title="5.2.4求最大公因数"></a>5.2.4求最大公因数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> b != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> gcd(b, a%b)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        a,b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())   <span class="hljs-comment"># 注意输入格式的应用</span><br>        <span class="hljs-built_in">print</span>(gcd(a,b))<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        cout &lt;&lt; <span class="hljs-built_in">gcd</span>(a, b) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-3素数"><a href="#5-3素数" class="headerlink" title="5.3素数"></a>5.3素数</h3><h4 id="5-3-1-欧拉函数（O（-sqrt-n-））"><a href="#5-3-1-欧拉函数（O（-sqrt-n-））" class="headerlink" title="5.3.1 欧拉函数（O（$\sqrt{n}$））"></a>5.3.1 欧拉函数（O（$\sqrt{n}$））</h4><p>用公式：$N\prod_i^k(1-1&#x2F;p_i)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>        res = a<br>        i = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">while</span> i &lt;= a // i:<br>            <span class="hljs-keyword">if</span> a % i == <span class="hljs-number">0</span>:<br>                res = res * (<span class="hljs-number">1</span> - <span class="hljs-number">1</span>/i)    <span class="hljs-comment"># 小细节，这里故意不用整除，因为就是要小数去乘</span><br>                <span class="hljs-keyword">while</span> a % i == <span class="hljs-number">0</span>:<br>                    a //= i<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">1</span>:<br>            res = res * (<span class="hljs-number">1</span> - <span class="hljs-number">1</span>/a)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(res))<br>        n -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        <span class="hljs-type">int</span> res = a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a % i == <span class="hljs-number">0</span>)<br>                res = res / i * (i - <span class="hljs-number">1</span>);  <span class="hljs-comment">//注意此处：*(1 - 1 / i) 要的就是该乘小数时乘小数</span><br>                                           <span class="hljs-comment">//因此可以优化成先除后乘</span><br>            <span class="hljs-keyword">while</span>(a % i == <span class="hljs-number">0</span>)<br>                a /= i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1</span>)<br>            res = res / a * (a - <span class="hljs-number">1</span>);<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-3-2筛法求欧拉函数数-O-n"><a href="#5-3-2筛法求欧拉函数数-O-n" class="headerlink" title="5.3.2筛法求欧拉函数数(O($n$))"></a>5.3.2筛法求欧拉函数数(O($n$))</h4><p>题目：求1~n之间的数的欧拉函数之和</p>
<p>运用筛法求素数的方法，当筛选到一个数时，考虑以下情况：</p>
<ul>
<li>x是素数：eulers[x] &#x3D; x - 1</li>
<li>x &#x3D; i*prime[j],并且i % prime[j] &#x3D; 0，则eulers[x] &#x3D; prime[j] * eulers[i]。因为此时prime[j]是i的最小质因子，公式$N\prod_i^k(1-1&#x2F;p_i)$只与$p_i$相关，与它的次数无关，而prime[j]的$p_i$又一定是包含于i的$p_i$中的，所以eulers[x] &#x3D; prime[j] * i * $\prod_i^k(1-1&#x2F;p_i)$ &#x3D; prime[j] * eulers[i]</li>
<li>x &#x3D; i*prime[j],并且i % prime[j] !&#x3D; 0, 则eulers[x] &#x3D; eulers[prime[j]] * eulers[i]。因为此时prime[j]不是i的因子，那么prime[j]的$p_j$不包含于i的$p_i$，那么此时eulers[x] &#x3D; prime[j] * $(1-1&#x2F;p_j)$ * i * $\prod_i^k(1-1&#x2F;p_i)$  &#x3D; eulers[prime[j]] * eulers[i]</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>)<br>is_prime = [<span class="hljs-literal">True</span>] * N<br>prime = [<span class="hljs-number">0</span>] * N<br>eulers = [<span class="hljs-number">0</span>] * N<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_eulers</span>(<span class="hljs-params">n</span>):<br>    eulers[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    cnt = <span class="hljs-number">0</span>      <span class="hljs-comment"># 记录此时prime数组的尾巴</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> is_prime[i] == <span class="hljs-literal">True</span>:<br>            prime[cnt] = i<br>            cnt += <span class="hljs-number">1</span><br>            eulers[i] = i - <span class="hljs-number">1</span>    <span class="hljs-comment"># 情况一</span><br>        j = <span class="hljs-number">0</span>     <br>        <span class="hljs-keyword">while</span> prime[j] &lt;= n // i:<br>            t = i * prime[j]<br>            is_prime[t] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> i % prime[j] == <span class="hljs-number">0</span>:<br>                eulers[t] = prime[j] * eulers[i]  <span class="hljs-comment"># 情况3</span><br>                <span class="hljs-keyword">break</span><br>            eulers[t] = eulers[i] * eulers[prime[j]]  <span class="hljs-comment"># 请况2</span><br>            j += <span class="hljs-number">1</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        res += eulers[i]<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-built_in">print</span>(get_eulers(n))<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">bool</span> is_prime[N];<br><span class="hljs-type">int</span> prime[N], cnt;<br><span class="hljs-type">int</span> eulers[N];<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;    <br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    eulers[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(is_prime[i] == <span class="hljs-literal">false</span>)<br>        &#123;<br>            eulers[i] = i - <span class="hljs-number">1</span>;<br>            prime[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] * i &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> t = i * prime[j];<br>            is_prime[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                eulers[t] = eulers[i]*prime[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            eulers[t] = eulers[i] * eulers[prime[j]];<br>        &#125;<br>    &#125;<br>    LL res = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 注意res开LL，否则会溢出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        res += eulers[i];<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-4快速幂O-log-k-k为次数"><a href="#5-4快速幂O-log-k-k为次数" class="headerlink" title="5.4快速幂O(log(k)),k为次数"></a>5.4快速幂O(log(k)),k为次数</h3><p>和数论课本里的一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span> % p;    <span class="hljs-comment">// 注意这里开res的时候就要mod p了，目的是为了处理当p=1时的特殊情况，当p=1时，res一定为0，因为任何数mod 1都为0</span><br>    <span class="hljs-keyword">while</span>(k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>)    <span class="hljs-comment">// k二进制末尾是1</span><br>            res = (LL)res * a % p;   <span class="hljs-comment">// 当前a % p算入结果</span><br>        k &gt;&gt;= <span class="hljs-number">1</span>;     <span class="hljs-comment">// k右移一位</span><br>        a = (LL)a * a % p;  <span class="hljs-comment">// 更新a</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a, k, p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;k, &amp;p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">qmi</span>(a, k, p));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">qmi</span>(<span class="hljs-params">a, b, p</span>):<br>    res = <span class="hljs-number">1</span> % p<br>    <span class="hljs-keyword">while</span> b:<br>        <span class="hljs-keyword">if</span> b &amp; <span class="hljs-number">1</span>:<br>            res = res * a % p<br>        b &gt;&gt;= <span class="hljs-number">1</span><br>        a = a * a % p<br>    <span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        a, b, p = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-built_in">print</span>(qmi(a, b, p))<br>        n -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>用python的好处是不用考虑数字类型</p>
<h3 id="5-5、逆元"><a href="#5-5、逆元" class="headerlink" title="5.5、逆元"></a>5.5、逆元</h3><h4 id="5-5-1、快速幂求逆元"><a href="#5-5-1、快速幂求逆元" class="headerlink" title="5.5.1、快速幂求逆元"></a>5.5.1、快速幂求逆元</h4><p>（只有当p为质数时才可以用快速幂求逆元，否则可以用拓展欧几里得算法来求）：满足$b<em>x &#x3D; 1(mod p)$的x称为b的逆元，而当p为素数时有b</em>b^(p-2) &#x3D; 1(mod p),那么此时b^(p-2)即为b的逆元。注意，当p|b时，b在mod p的情况下无逆元。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">qmi</span>(<span class="hljs-params">a, b, p</span>):<br>    res = <span class="hljs-number">1</span> % p<br>    <span class="hljs-keyword">while</span> b:<br>        <span class="hljs-keyword">if</span> b &amp; <span class="hljs-number">1</span>:<br>            res = res * a % p<br>        b &gt;&gt;= <span class="hljs-number">1</span><br>        a = a * a % p<br>    <span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        a, p = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        res = qmi(a, p-<span class="hljs-number">2</span>, p)<br>        <span class="hljs-keyword">if</span> a % p:<br>            <span class="hljs-built_in">print</span>(res)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;impossible&quot;</span>)<br>        n -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)<br>            res = (LL)res * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (LL)a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, p;<br>        cin &gt;&gt; a &gt;&gt; p;<br>        <span class="hljs-keyword">if</span>(a % p == <span class="hljs-number">0</span>)    <span class="hljs-comment">// p是质数，如果p不能整除a，就可以说明a和p互素</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-5-2-扩展欧几里得算法求逆元"><a href="#5-5-2-扩展欧几里得算法求逆元" class="headerlink" title="5.5.2 扩展欧几里得算法求逆元"></a>5.5.2 扩展欧几里得算法求逆元</h4><p>当p不为素数时，更为广泛的求法是用拓展欧几里得算法求逆元</p>
<p>实际上就是算ax&#x3D;1(mod m)的x，exgcd(a, m, x, y)，求出x即为解</p>
<p>注意：逆元要求a，m互素，如果不互素，就输出impossible无解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y ,x);<br>        y -= a / b * x;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, x, y;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a, b, x, y);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> % d) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; (x % b + b) % b &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="5-6-拓展欧几里得算法"><a href="#5-6-拓展欧几里得算法" class="headerlink" title="5.6 拓展欧几里得算法"></a>5.6 拓展欧几里得算法</h3><h4 id="5-6-1-拓展欧几里得算法-实际上就是辗转相除法的逆运算"><a href="#5-6-1-拓展欧几里得算法-实际上就是辗转相除法的逆运算" class="headerlink" title="5.6.1 拓展欧几里得算法(实际上就是辗转相除法的逆运算)"></a>5.6.1 拓展欧几里得算法(实际上就是辗转相除法的逆运算)</h4><p>辗转相除法也称欧几里得算法</p>
<p>要求：对给定的任意正整数a，b，要求求出一组x，y使得ax + by &#x3D;（a，b）</p>
<p>原理：</p>
<ul>
<li>第一种情况：若b &#x3D; 0，则（a，0）&#x3D; a，那么a*1+b*0 &#x3D; a, 此时x &#x3D; 1，y &#x3D; 0</li>
<li>第二种情况：对（a,b)&#x3D;(b，a%b)，有by+a%b*x&#x3D;d  &#x3D;&gt;  by+(a-[a&#x2F;b]*b)*x&#x3D;d  &#x3D;&gt;  b(y-[a&#x2F;b]*x)+ax&#x3D;d</li>
</ul>
<p>就是每次循环y都得减去[a&#x2F;b]*a</p>
<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20241214110040594.png" srcset="/img/loading.gif" lazyload alt="image-20241214110040594" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span>    <span class="hljs-comment">// 引用x， y</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b != <span class="hljs-number">0</span>)     <span class="hljs-comment">// 情况2</span><br>    &#123;<br>        <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);  <span class="hljs-comment">// 注意y，x颠倒顺序，方便迭代</span><br>        y -= a / b * x;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <span class="hljs-keyword">else</span>           <span class="hljs-comment">// 情况1</span><br>    &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, x, y;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">exgcd</span>(a, b, x, y);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, x, y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">exgcd</span>(<span class="hljs-params">a, b, x, y</span>):<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> a, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        d, y, x = exgcd(b, a%b, y, x)<br>        y -= (a // b)*x<br>        <span class="hljs-keyword">return</span> d, x, y<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        _, x, y = exgcd(a, b, x, y)<br>        <span class="hljs-built_in">print</span>(x, y)<br></code></pre></td></tr></table></figure>

<p>python不支持引用，但支持返回多个值，所以可以通过每次返回x， y，来改变x，y的值。</p>
<h4 id="5-6-2-求线性同余方程"><a href="#5-6-2-求线性同余方程" class="headerlink" title="5.6.2 求线性同余方程"></a>5.6.2 求线性同余方程</h4><p>直接用拓展欧几里得算法求就行</p>
<p>求ax&#x3D;b(mod m)， d &#x3D; (a, m)</p>
<ul>
<li>情况1：若d|b,则有解，用拓展欧几里得求出ax+my&#x3D;d，则x* b&#x2F;d即为解</li>
<li>情况2：d不能整除b，则无解</li>
</ul>
<p>注意：程序只求一个解，实际上有d个解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>        y -= a / b * x;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, m, x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;m);<br>        <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a, m, x, y);<br>        <span class="hljs-keyword">if</span>(b % d) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (LL)x * (b / d) % m);    <span class="hljs-comment">// 注意要用LL型</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">exgcd</span><span class="hljs-params">(a, b, x, y)</span>:</span><br><span class="hljs-function">    if(b =</span>= <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> a, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        d, y, x = <span class="hljs-built_in">exgcd</span>(b, a%b, y, x)<br>        y -= a <span class="hljs-comment">// b * x</span><br>        <span class="hljs-keyword">return</span> d, x, y<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        a, b, m = <span class="hljs-built_in">map</span>(<span class="hljs-type">int</span>, <span class="hljs-built_in">input</span>().<span class="hljs-built_in">split</span>())<br>        d, x, y = <span class="hljs-built_in">exgcd</span>(a, m, x, y)<br>        <span class="hljs-keyword">if</span> b % d != <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;impossible&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(x * b <span class="hljs-comment">// d % m)</span><br></code></pre></td></tr></table></figure>



<h3 id="5-7-中国剩余定理"><a href="#5-7-中国剩余定理" class="headerlink" title="5.7 中国剩余定理"></a>5.7 中国剩余定理</h3><p>采用两两组合的方式求中国剩余定理</p>
<p>假设有两个同余方程：x&#x3D;a1(mod m1)      x&#x3D;a2(mod m2)</p>
<p>则先在0~[m1, m2] 找是否有k1*m1+a1 &#x3D; k2*m2+a2，转换一下变成k1*m1-k2*m2 &#x3D; a2-a1,也即求exgcd(m1,m2,k1,k2)，然后算出k1</p>
<p>那么将两同余方程合并后a1 &#x3D; m1*k1+a1, m1 &#x3D; [m1, m2] &#x3D; m1*m2 &#x2F; (m1,m2)</p>
<p>最后一直组合，最后得到的a1即为解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">exgcd</span><span class="hljs-params">(LL a, LL b, LL &amp;x, LL &amp;y)</span>  <span class="hljs-comment">// 扩展欧几里得算法求k1</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LL d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>        y -= a / b * x;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    LL a1, m1, x = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; m1 &gt;&gt; a1;<br>    n --;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        LL a2, m2, k1, k2;<br>        cin &gt;&gt; m2 &gt;&gt; a2;<br>        LL d = <span class="hljs-built_in">exgcd</span>(m1, m2, k1, k2);<br>        <span class="hljs-keyword">if</span>((a2 - a1) % d)       <span class="hljs-comment">// 一旦有一组无解，则整个方程组都无解</span><br>        &#123;<br>            x = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        k1 *= (a2 - a1) / d;   <span class="hljs-comment">// 求出最小的正整数k1即可</span><br>        LL t = m2 / d;<br>        k1 = (k1%t + t) % t;<br>        <br>        a1 = k1 * m1 + a1;    <span class="hljs-comment">// 更新a1</span><br>        m1 = <span class="hljs-built_in">abs</span>(m1 * m2 / d);     <span class="hljs-comment">// 更新m1，最小公倍数定义大于0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(x != <span class="hljs-number">-1</span>)<br>        x = (a1 % m1 + m1) % m1;  <span class="hljs-comment">// 求出最小的正整数a1</span><br>    cout &lt;&lt; x;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">exgcd</span>(<span class="hljs-params">a, b, x, y</span>):<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> a, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>:<br>        d, y, x = exgcd(b, a % b, y, x)<br>        y -= a // b * x<br>        <span class="hljs-keyword">return</span> d, x, y<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    x = <span class="hljs-number">0</span><br>    m1, a1 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    n -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        m2, a2 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        k1, k2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        d, k1, k2 = exgcd(m1, m2, k1, k2)<br>        <span class="hljs-keyword">if</span> (a2 - a1) % d:<br>            x = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">break</span><br>        k1 = k1 * (a2 - a1) // d<br>        t = m2 // d<br>        k1 = (k1 % t + t)%t<br>        <br>        a1 = m1 * k1 + a1<br>        m1 = <span class="hljs-built_in">abs</span>(m1 * m2 // d)<br>    <span class="hljs-keyword">if</span> x != -<span class="hljs-number">1</span>:<br>        x = (a1 % m1 + m1) % m1<br>    <span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure>









<h3 id="5-8、高斯消元求解线性方程组"><a href="#5-8、高斯消元求解线性方程组" class="headerlink" title="5.8、高斯消元求解线性方程组"></a>5.8、高斯消元求解线性方程组</h3><p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20241217164542921.png" srcset="/img/loading.gif" lazyload alt="image-20241217164542921"></p>
<p><img src="/../../../AppData/Roaming/Typora/typora-user-images/image-20241217165355841.png" srcset="/img/loading.gif" lazyload alt="image-20241217165355841"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> a[N][N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span>    <span class="hljs-comment">// 遍历逻辑：遍历每一列</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c, r;<span class="hljs-comment">// c 代表 列 col ， r 代表 行 row</span><br>    <span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; c &lt; n; c ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = r;<span class="hljs-comment">// 先找到当前这一列，绝对值最大的一个数字所在的行号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; <span class="hljs-built_in">fabs</span>(a[t][c]))<br>                t = i;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[t][c]) &lt; eps) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c; i &lt; n + <span class="hljs-number">1</span>; i ++ ) <span class="hljs-built_in">swap</span>(a[t][i], a[r][i]);<span class="hljs-comment">//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];<span class="hljs-comment">// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++ )<span class="hljs-comment">// 把当前列下面的所有数，全部消成 0</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; eps)<span class="hljs-comment">// 如果非0 再操作，已经是 0就没必要操作了</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= c; j -- )<span class="hljs-comment">// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][c] -= 1*a[i][c];</span><br>                    a[i][j] -= a[r][j] * a[i][c];<br><br>        r ++ ;<span class="hljs-comment">// 这一行的工作做完，换下一行</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r &lt; n)<span class="hljs-comment">// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解</span><br>    &#123;<span class="hljs-comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<span class="hljs-comment">// </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<span class="hljs-comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程</span><br>    &#125;<br>    <span class="hljs-comment">// 唯一解 ↓，从下往上回代，得到方程的解</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++ )<br>            a[i][n] -= a[j][n] * a[i][j];<span class="hljs-comment">//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">1</span>; j ++ )<br>            cin &gt;&gt; a[i][j];<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">gauss</span>();<br><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, a[i][n]);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Infinite group solutions&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No solution&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-9、组合数"><a href="#5-9、组合数" class="headerlink" title="5.9、组合数"></a>5.9、组合数</h3><p>主要根据题目给出的数的多少来确定用哪一个模板求$C^a_b$</p>
<p>如果是求n个组合数，则考虑模板Ⅰ、Ⅱ，递归或者初始化阶乘数组</p>
<p>如果只求一个组合数，要求mod p时可考虑lucas定理（如Ⅲ），无mod p时则要考虑将组合数展开（如Ⅳ）</p>
<h4 id="5-9-1、组合数Ⅰ-O-n-2"><a href="#5-9-1、组合数Ⅰ-O-n-2" class="headerlink" title="5.9.1、组合数Ⅰ O(n^2)"></a>5.9.1、组合数Ⅰ O(n^2)</h4><p>在a,b&lt;2000范围内求组合数,用公式 $C^b_a &#x3D; C_{a-1}^{b-1} + C_{a-1}^b$</p>
<p>可以理解为选中一个个体，分为选他和不选他两种情况，选他，则从另外a-1个中选b-1个；不选，则从另外a-1个中选b个</p>
<p>因为数字范围比较小，可以直接一开始就把全部组合数都算出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> c[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % Mod;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        cout &lt;&lt; c[a][b] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">2010</span>)<br>Mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>c = [[<span class="hljs-number">0</span>]*N <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]  <span class="hljs-comment"># python中定义所有元素为0的N*N的二维数组</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                c[i][j] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                c[i][j] = (c[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+c[i-<span class="hljs-number">1</span>][j]) % Mod<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    init()<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span>(n):<br>        n -= <span class="hljs-number">1</span><br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-built_in">print</span>(c[a][b])<br></code></pre></td></tr></table></figure>



<h4 id="5-9-2、组合数Ⅱ-O-n-log-n"><a href="#5-9-2、组合数Ⅱ-O-n-log-n" class="headerlink" title="5.9.2、组合数Ⅱ O(n*log(n))"></a>5.9.2、组合数Ⅱ O(n*log(n))</h4><p>此时a，b的范围给至100000，全部算出组合数会超时，于是我们看公式 $C^b_a&#x3D;\frac{a!}{(a-b)!*b!}$</p>
<p>转换一下变成$C_a^b&#x3D;a!<em>((a-b)!)^{-1}</em>(b!)^{-1}$</p>
<p>那么我们就直接算0~N每个元素的阶层，以及它们阶乘的逆，然后求哪个就将哪个对应的阶乘代入公式即可</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, Mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> fact[N], infact[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>)<br>        &#123;<br>            res = (LL)res * a % p;<br>        &#125;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (LL)a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>   <span class="hljs-comment">//每个运算都要变成LL，防止溢出</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        fact[i] = (LL)fact[i<span class="hljs-number">-1</span>] * i % Mod;<br>        infact[i] = (LL)infact[i<span class="hljs-number">-1</span>] * <span class="hljs-built_in">qmi</span>(i, Mod - <span class="hljs-number">2</span>, Mod) % Mod;<br>    &#125;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        cout &lt;&lt; (LL)fact[a] * infact[a-b] % Mod * infact[b] % Mod &lt;&lt; endl;<br>        <span class="hljs-comment">// 两个LL相乘之后必须先取模，要不会溢出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>)<br>Mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>fact = [<span class="hljs-number">0</span>] * N<br>infact = [<span class="hljs-number">0</span>] * N<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">qmi</span>(<span class="hljs-params">a, k, p</span>):<br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k:<br>        <span class="hljs-keyword">if</span> k &amp; <span class="hljs-number">1</span>:<br>            res = res * a % p<br>        k &gt;&gt;= <span class="hljs-number">1</span><br>        a = a * a % p<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>        fact[i] = fact[i-<span class="hljs-number">1</span>] * i % Mod<br>        infact[i] = infact[i-<span class="hljs-number">1</span>] * qmi(i, Mod-<span class="hljs-number">2</span>, Mod) % Mod<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-built_in">print</span>(fact[a]*infact[a-b]%Mod*infact[b] % Mod)<br></code></pre></td></tr></table></figure>



<h4 id="5-9-3、组合数Ⅲ"><a href="#5-9-3、组合数Ⅲ" class="headerlink" title="5.9.3、组合数Ⅲ"></a>5.9.3、组合数Ⅲ</h4><p>题目：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">给定 n组询问，每组询问给定三个整数 <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,<span class="hljs-selector-tag">p</span>，其中 <span class="hljs-selector-tag">p</span>是质数，请你输出 Cbamodp的值。<br><br>输入格式<br>第一行包含整数 n。<br>接下来 n行，每行包含一组 <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,<span class="hljs-selector-tag">p</span>。<br><br>输出格式<br>共 n行，每行输出一个询问的解。<br></code></pre></td></tr></table></figure>



<p>此时数据来到10^18，上述两种方法必定超时，而题目又说有mod p，因此想到Lucas定理</p>
<p>$C_a^b&#x3D;C^{\frac{b}{p}}<em>{\frac{a}{p}}*C^{bmodp}</em>{amodp} (mod p)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">int</span> p;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (LL)a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(LL a, LL b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(b &gt; a) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i++, j--) <span class="hljs-comment">//例如a=5，b=3，不就是5*4*3/3！吗，循环次数取决于b</span><br>    &#123;<br>        res = (LL)res * j % p;<br>        res = (LL)res * <span class="hljs-built_in">qmi</span>(i, p<span class="hljs-number">-2</span>, p) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(LL a, LL b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a, b, p);<br>    <span class="hljs-keyword">return</span> (LL)<span class="hljs-built_in">lucas</span>(a/p, b/p, p) * <span class="hljs-built_in">C</span>(a%p, b%p, p) % p; <span class="hljs-comment">//注意a/p可能还是大于p，所以还得用lucas定理</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        LL a, b;   <span class="hljs-comment">// a, b范围为10^18</span><br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>        cout &lt;&lt; <span class="hljs-built_in">lucas</span>(a, b, p) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">qmi</span>(<span class="hljs-params">a, k, p</span>):<br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k:<br>        <span class="hljs-keyword">if</span> k &amp; <span class="hljs-number">1</span>:<br>            res = res * a % p<br>        k &gt;&gt;= <span class="hljs-number">1</span><br>        a = a * a % p<br>    <span class="hljs-keyword">return</span> res<br>            <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">C</span>(<span class="hljs-params">a, b, p</span>):<br>    res = <span class="hljs-number">1</span><br>    j = a<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, b+<span class="hljs-number">1</span>):<br>        res = res * j % p<br>        j-=<span class="hljs-number">1</span><br>        res = res * qmi(i, p-<span class="hljs-number">2</span>, p) % p<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lucas</span>(<span class="hljs-params">a, b, p</span>):<br>    <span class="hljs-keyword">if</span> b &gt; a:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> a &lt; p <span class="hljs-keyword">and</span> b &lt; p:<br>        <span class="hljs-keyword">return</span> C(a, b, p)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> lucas(a//p, b//p, p) * C(a%p, b%p, p) % p<br>    <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">while</span> n:<br>        n -= <span class="hljs-number">1</span><br>        a, b, p = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        <span class="hljs-built_in">print</span>(lucas(a, b, p))<br>        <br></code></pre></td></tr></table></figure>







<h4 id="5-9-4、组合数Ⅳ"><a href="#5-9-4、组合数Ⅳ" class="headerlink" title="5.9.4、组合数Ⅳ"></a>5.9.4、组合数Ⅳ</h4><p>此时题目没有要求模1e9+7，这就意味结果着可能会连LL都容纳不了，因此我们用高精度乘法来算$C_a^b$,同时也不能用逆元了（没有mod的数）</p>
<ul>
<li>首先先求出2~n的全体素数</li>
<li>求$a!$、$b!$ 、$(a-b)!$的展开式中每个素数的次数，汇总入sum数组中，形成$C^b_a$的展开式</li>
<li>用高精度乘计算$C^b_a$的展开式的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-type">int</span> primes[N];      <span class="hljs-comment">//每个素数都有对应的sum</span><br><span class="hljs-type">bool</span> is_prime[N];<br><span class="hljs-type">int</span> sum[N];<br><span class="hljs-type">int</span> cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(is_prime[i] == <span class="hljs-literal">false</span>)<br>            primes[cnt++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] * i &lt;= n; j ++)<br>        &#123;<br>            is_prime[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a)        <span class="hljs-comment">// 其实就相当于a/p、a/p^2、a/p^3……</span><br>    &#123;<br>        res += a / p;<br>        a /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        t += a[i] * b;<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)<br>    &#123;<br>        res.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-built_in">find_primes</span>(a);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>    &#123;<br>        sum[i] = <span class="hljs-built_in">get</span>(a, primes[i]) - <span class="hljs-built_in">get</span>(b, primes[i]) - <span class="hljs-built_in">get</span>(a-b, primes[i]);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; sum[i]; j++)<br>            res = <span class="hljs-built_in">mul</span>(res, primes[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        cout &lt;&lt; res[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>python直接乱杀，factorial(n)可以直接算出n的阶乘，也不用高精度</p>
<p>但主要是这题只用算一个组合数，前面三种直接用阶乘算的话会超时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">C</span>(<span class="hljs-params">n, m</span>):<br>    <span class="hljs-keyword">return</span> math.factorial(n) // math.factorial(n-m) // math.factorial(m)<br><br>a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-built_in">print</span>(C(a, b))<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">5010</span>)<br>is_prime = [<span class="hljs-literal">True</span>] * N<br>prime = [<span class="hljs-number">0</span>] * N<br><span class="hljs-built_in">sum</span> = [<span class="hljs-number">0</span>] * N<br>cnt = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_prime</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">global</span> cnt<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> is_prime[i] == <span class="hljs-literal">True</span>:<br>            prime[cnt] = i<br>            cnt +=<span class="hljs-number">1</span><br>        j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i * prime[j] &lt;= n:<br>            is_prime[i * prime[j]] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> i % prime[j] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            j += <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">a, p</span>):<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> a:<br>        res += a // p<br>        a //= p<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">qmi</span>(<span class="hljs-params">a, k, p</span>):<br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k:<br>        <span class="hljs-keyword">if</span> k &amp; <span class="hljs-number">1</span>:<br>            res = res * a % p<br>        k &gt;&gt;= <span class="hljs-number">1</span><br>        a = a * a % p<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    res = <span class="hljs-number">1</span><br>    find_prime(a)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>        <span class="hljs-built_in">sum</span>[i] = get(a, prime[i]) - get(a - b, prime[i]) - get(b, prime[i])<br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">sum</span>[i]):<br>            res *= prime[i]<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>





<p>对于只求一次的组合数，我们一般的思路有以下两种：</p>
<p>* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i++, j--) <span class="hljs-comment">//例如a=5，b=3，不就是5*4*3/3！吗，循环次数取决于b</span><br>    &#123;<br>        res = (LL)res * j % p;<br>        res = (LL)res * <span class="hljs-built_in">qmi</span>(i, p<span class="hljs-number">-2</span>, p) % p;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a; i &gt; a - b; i--)<br>        res = (LL)res * i % mod;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b; i++)<br>        res = (LL)res * <span class="hljs-built_in">qmi</span>(i, mod<span class="hljs-number">-2</span>, mod) % mod;<br></code></pre></td></tr></table></figure>





<h4 id="5-9-5、求满足要求的01序列"><a href="#5-9-5、求满足要求的01序列" class="headerlink" title="5.9.5、求满足要求的01序列"></a>5.9.5、求满足要求的01序列</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定 n个 0和 n个 1，它们将按照某种顺序排成长度为<span class="hljs-number"> 2 </span>的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中<span class="hljs-number"> 0 </span>的个数都不少于<span class="hljs-number"> 1 </span>的个数的序列有多少个。<br>输出的答案对 109+7取模。<br></code></pre></td></tr></table></figure>

<ul>
<li>思路</li>
</ul>
<p>将 01序列置于坐标系中，起点定于原点。若 0表示向右走，1表示向上走，那么任何前缀中 0的个数不少于 1<br> 的个数就转化为，&#x3D;&#x3D;路径上的任意一点&#x3D;&#x3D;，横坐标大于等于纵坐标。题目所求即为这样的合法路径数量。</p>
<p>下图中，表示从 (0,0)走到 (n,n)的路径，在绿线及以下表示合法，若触碰红线即不合法。</p>
<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20241228162047860.png" srcset="/img/loading.gif" lazyload alt="image-20241228162047860" style="zoom:50%;" />

<p>由图可知，任何一条合法的路径（如黑色路径），都对应一条从 (0,0)走到 (n−1,n+1)的一条路径（如灰色路径）。而任何一条 (0,0)走到 (n−1,n+1)的路径，也对应了一条从 (0,0)走到 (n,n)的合法路径。</p>
<p>答案如图，即卡特兰数  &#x3D; $\frac{C_{2n}^n}{n+1}$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k ,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>)<br>            res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>*n, b = n;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a; i &gt; a - b; i--)<br>        res = (LL)res * i % mod;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b; i++)<br>        res = (LL)res * <span class="hljs-built_in">qmi</span>(i, mod<span class="hljs-number">-2</span>, mod) % mod;<br>    res = (LL)res * <span class="hljs-built_in">qmi</span>(n + <span class="hljs-number">1</span>, mod - <span class="hljs-number">2</span>, mod) % mod;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">mod = <span class="hljs-built_in">int</span>(<span class="hljs-number">1e9</span>+ <span class="hljs-number">7</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">qmi</span>(<span class="hljs-params">a, k, p</span>):<br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k:<br>        <span class="hljs-keyword">if</span> k &amp; <span class="hljs-number">1</span>:<br>            res = res * a % p<br>        k &gt;&gt;= <span class="hljs-number">1</span><br>        a = a * a % p<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    res = <span class="hljs-number">1</span><br>    i = <span class="hljs-number">2</span>*n<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>        res = res * i % mod<br>        i -= <span class="hljs-number">1</span><br>        res = res * qmi(j, mod-<span class="hljs-number">2</span>, mod) % mod<br>    res = res * qmi(n+<span class="hljs-number">1</span>, mod - <span class="hljs-number">2</span>, mod) % mod<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<ul>
<li>卡特兰数还可用于解决进出栈问题</li>
</ul>
<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20241228163259517.png" srcset="/img/loading.gif" lazyload alt="image-20241228163259517" style="zoom:33%;" />

<p>要求每一时刻出栈次数小于进栈次数，可以抽象成上边的图，一旦不满足则相当于触碰到了红线。</p>
<h3 id="5-10、容斥原理"><a href="#5-10、容斥原理" class="headerlink" title="5.10、容斥原理"></a>5.10、容斥原理</h3><h4 id="5-10-1能被整除的数"><a href="#5-10-1能被整除的数" class="headerlink" title="5.10.1能被整除的数"></a>5.10.1能被整除的数</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">给定一个整数 n和 m个不同的质数 <span class="hljs-built_in">p1</span>,<span class="hljs-built_in">p2</span>,…,pm。<br>请你求出 <span class="hljs-number">1</span>∼n中能被 <span class="hljs-built_in">p1</span>,<span class="hljs-built_in">p2</span>,…,pm中的至少一个数整除的整数有多少个。<br></code></pre></td></tr></table></figure>



<p>把能被pk整除的数看成一个集合，则那不就是求这些集合的交集的元素个数吗，不就是容斥原理吗？</p>
<p>就是$|S_1\cup S_2\cup …\cup S_m|&#x3D;|S_1|+…+|S_m|-|S_1\cap S_2|-|S_1 \cap S_3|…$</p>
<p>其中$S_1$表示能被$p_1$整除的数的集合，那么$|S_1|&#x3D;\frac{n}{p_1}$</p>
<ul>
<li>时间复杂度：从m个集合中选1个集合、2个集合…m个集合的总方案数是$2^n$种，我们需要对这每一种方案进行分析，在每一种方案的分析过程种，我们又要去遍历每个集合，因此总的时间复杂度是$O(2^m *m)$</li>
<li>思路：遍历每种方案，每种方案都要遍历这m个集合，看它们有无被选中，得到最终的集合数量以及对应的质数积，进而得到在这些选中集合的交集的元素个数。</li>
<li>技巧：位运算表示集合选中状态，例如，4个集合的情况：用0001~1111的二进制数表示集合选中情况，如0101表示选中集合1、3，那么一共就是$2^n-1$种方案（不可能一个都不选），对每一种方案遍历这4位数，若为1，则更新选中集合数和质数积，然后如果有偶数个集合被选中（二进制中1的个数为偶数），则减去这个交集的元素个数，否则加上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">//素数集合</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>        cin &gt;&gt; p[i];<br>        <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;     <br>    <span class="hljs-comment">//遍历每一个方案，遍历到i = 2^m-1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; m; i++)  <br>    &#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 当前是几个集合的交集</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 当前选取的素数的乘积</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)  <span class="hljs-comment">// 遍历该方案的每一位（每一个集合）</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>)           <span class="hljs-comment">// j号集合被选中</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>((LL)p[j] * t &gt; n)  <span class="hljs-comment">// 超过n，说明交集为空</span><br>                &#123;<br>                    s = <span class="hljs-number">-1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                s ++;<br>                t = (LL)t * p[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(s % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  res -= n / t;<br>        <span class="hljs-keyword">else</span> res += n / t;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>)<br>p = [<span class="hljs-number">0</span>] * N<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    p = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))  <span class="hljs-comment"># python对于将一行输入元素存储进列表中的做法</span><br>    <br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;&lt; m):<br>        t = <span class="hljs-number">0</span><br>        s = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">if</span> i &gt;&gt; j &amp; <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> p[j]*s &gt; n:<br>                    s = -<span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>                t += <span class="hljs-number">1</span><br>                s *= p[j]<br>        <span class="hljs-keyword">if</span> s == -<span class="hljs-number">1</span>: <br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            res -= n // s<br>        <span class="hljs-keyword">else</span>:<br>            res += n // s<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>





<h3 id="5-11博弈论"><a href="#5-11博弈论" class="headerlink" title="5.11博弈论"></a>5.11博弈论</h3><h4 id="5-11-1-Nim游戏"><a href="#5-11-1-Nim游戏" class="headerlink" title="5.11.1 Nim游戏"></a>5.11.1 Nim游戏</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定 <span class="hljs-built_in">n</span>堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。<br></code></pre></td></tr></table></figure>

<p>若一个游戏满足：</p>
<p>1、由两名玩家交替行动</p>
<p>2、在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关</p>
<p>3、不能行动的玩家判负</p>
<p>则称该游戏为一个公平组合游戏。Nim游戏是一个公平组合游戏</p>
<ul>
<li>题目举例</li>
</ul>
<p>有两堆石子，2和3个，先手先从3个石子那堆拿出一个，然后后手拿几个，先手就在另一堆石子镜像地拿几个，那么此时先手一定必胜</p>
<ul>
<li><strong>必胜状态与必败状态</strong></li>
</ul>
<p>&#x3D;&#x3D;必胜状态&#x3D;&#x3D;:先手进行某一个操作，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即先手可以走到某一个必败状态。<br>&#x3D;&#x3D;必败状态&#x3D;&#x3D;:先手无论如何操作，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即先手走不到任何一个必败状态。</p>
<ul>
<li><strong>结论</strong></li>
</ul>
<p>假设有n堆石子，石子数目分别为$a_1,a_2,…,a_n$,则如果$a_1\bigoplus a_2\bigoplus …\bigoplus a_n &#x3D; x \neq 0$，则是先手必胜，若为0，则为先手必败</p>
<p>分析：如果$x\neq0$则先手一定可以从某一个石堆中拿一些石子使得$x&#x3D;0$，那么此时留给后手的是必败状态，后手无论怎么拿都会使得$x\neq0$，进而留给先手的又是一个必胜状态。所以一开始$x\neq0$就能使得先手必胜。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        res = res ^ x;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>res = <span class="hljs-number">0</span><br>x = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>    res ^= x[i]<br><span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br></code></pre></td></tr></table></figure>



<h4 id="5-11-2-台阶Nim游戏"><a href="#5-11-2-台阶Nim游戏" class="headerlink" title="5.11.2 台阶Nim游戏"></a>5.11.2 台阶Nim游戏</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">现在，有一个 n级台阶的楼梯，每级台阶上都有若干个石子，其中第 <span class="hljs-selector-tag">i</span>级台阶上有 ai个石子(<span class="hljs-selector-tag">i</span>≥<span class="hljs-number">1</span>)。<br>两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。<br>已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。<br>问如果两人都采用最优策略，先手是否必胜。<br></code></pre></td></tr></table></figure>

<ul>
<li><p>思路：将台阶Nim游戏转换为<strong>奇数台阶上的经典Nim游戏</strong>，即不管偶数台阶上的石子，只要奇数台阶上的石子异或不为0，则必胜；反之必败</p>
</li>
<li><p>先手时，若奇数台阶上石子异或不为0，则先手总有办法使得留给后手的奇数台阶上的石子异或为0。</p>
<p>  轮到后手时，如果<strong>后手移动偶数台阶石子</strong>，则先手把后手移动的石子继续移动到下一层，那么相当于奇数台阶上的石子数量没变，则<strong>留给后手的又是奇数台阶石子异或为0</strong>的情况；如果<strong>后手移动奇数台阶石子</strong>，留给先手的奇数台阶石子异或不为0，则<strong>先手又有办法使得奇数台阶石子异或为0</strong>。</p>
<p>  所以无论后手怎么移动石子，先手都有办法把奇数台阶石子异或为0的情况留给后手，后手必败。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n; <br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>) res ^= x;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    res = <span class="hljs-number">0</span><br>    x = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            res ^= x[i]<br>    <span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br></code></pre></td></tr></table></figure>





<h4 id="5-11-3-集合Nim游戏"><a href="#5-11-3-集合Nim游戏" class="headerlink" title="5.11.3 集合Nim游戏"></a>5.11.3 集合Nim游戏</h4><ul>
<li>题目</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定 <span class="hljs-built_in">n</span>堆石子以及一个由 k个不同正整数构成的数字集合 S。<br>现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。<br>问如果两人都采用最优策略，先手是否必胜。<br></code></pre></td></tr></table></figure>

<ul>
<li><p>mex()函数：S为非空集合，mex(S)就是求出不属于集合S的最小非负整数，如mex({1, 2, 3})&#x3D;0, mex({0,1})&#x3D;2</p>
</li>
<li><p>SG()函数：在有向图中，对每个结点x，设从x出发有k条有向边，分别到达结点$y_1,y_2,…,y_k$,定义$SG(x)&#x3D;mex({SG(y_1),…,SG(y_k)})$</p>
</li>
<li><p>**对于一个图G如果$SG(x)!&#x3D;0$，（x是起点）则先手必胜。**因为如果起点SG不为0，说明与他相连的状态一定有0，所以先手一定可以留给后手一个必败局面，而后手无论怎么做留给先手的又都是一个必胜局面。</p>
</li>
<li><p>对n个有向图，如果$SG(G_1)\bigoplus SG(G_2)\bigoplus …\bigoplus SG(G_k)!&#x3D;0$，则先手必胜，反之必败。</p>
</li>
<li><p>假设有一堆10个石子的石堆，集合为8、5，得出有向图</p>
  <img src="../../../AppData/Roaming/Typora/typora-user-images/image-20241229125836304.png" srcset="/img/loading.gif" lazyload alt="image-20241229125836304" style="zoom:33%;" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, M = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> f[M], s[N]; <span class="hljs-comment">// s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值</span><br><span class="hljs-type">int</span> n, m; <span class="hljs-comment">// n是可选择集合的个数，m是石子堆数 </span><br><br><span class="hljs-comment">//求出每个点的sg都需要知道与他相连的下一组点的sg，所以得用记忆化搜索</span><br><span class="hljs-comment">//求某点的sg，得把与该点相连的所有点的sg都加入一个集合，然后对这个集合进行mex操作，所得即为该点sg</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x];<br>    <span class="hljs-comment">//因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; S;   <span class="hljs-comment">// S存储所有于结点x相连的结点的sg值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i] &lt;= x) S.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">sg</span>(x - s[i])); <span class="hljs-comment">// x这堆石子的数量刚好够集合s[i]分</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ;i++)    <span class="hljs-comment">// 就是算mex(S),得出的就是sg(x)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!S.<span class="hljs-built_in">count</span>(i))  <br>        &#123;<br>            f[x] = i;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; s[i];<br>    cin &gt;&gt; m;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        res ^= <span class="hljs-built_in">sg</span>(x);    <span class="hljs-comment">//对每堆石子的sg异或</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(res != <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">N = <span class="hljs-built_in">int</span>(<span class="hljs-number">110</span>)<br>M = <span class="hljs-built_in">int</span>(<span class="hljs-number">10010</span>)<br>n, m = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>f = [-<span class="hljs-number">1</span>]*M<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sg</span>(<span class="hljs-params">y</span>):<br>    <span class="hljs-keyword">if</span> f[y] != -<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> f[y]<br>    S = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> s[i] &lt;= y:<br>            S.add(sg(y-s[i]))<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> S:<br>            f[y] = i<br>            <span class="hljs-keyword">return</span> i<br>        i += <span class="hljs-number">1</span> <br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    x = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        res ^= sg(x[i])<br>    <span class="hljs-keyword">if</span> res != <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure>







<h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><h4 id="6-1、区间问题"><a href="#6-1、区间问题" class="headerlink" title="6.1、区间问题"></a>6.1、区间问题</h4><h5 id="6-1-1、区间选点"><a href="#6-1-1、区间选点" class="headerlink" title="6.1.1、区间选点"></a>6.1.1、区间选点</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定 <span class="hljs-built_in">N</span>个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。<br>输出选择的点的最小数量。位于区间端点上的点也算作区间内。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">N</span>，表示区间数。<br>接下来 <span class="hljs-built_in">N</span>行，每行包含两个整数 ai,bi，表示一个区间的两个端点。<br></code></pre></td></tr></table></figure>



<p>思路：</p>
<ul>
<li>按区间右端点对区间进行升序排序，这样能够保证每次更新的点不会大于下一区间的右节点</li>
</ul>
<p> -————-</p>
<p>​         -—</p>
<p>图中如果更新的点为上边区间的右节点，则会大于下边区间的右节点，则大于下边区间的左节点，那么此时不会更新点，但实际上是要更新点的</p>
<p>也就是说按右节点进行排序是为了保证每次更新的点不会漏掉下一区间</p>
<ul>
<li>遍历每一个区间，如果当前区间包含先前的点，则直接下一个；若当前区间不包含先前的点，则要多选一个点，选当前区间的右端点</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>rang = []<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        heapq.heappush(rang, (b, a))<br>    eg = -<span class="hljs-number">0x3f3f3f3f</span><br>    res = <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        r, l = heapq.heappop(rang)<br>        <span class="hljs-keyword">if</span> eg &lt; l:<br>            eg = r <br>            res += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<h5 id="6-1-2、最大不相交区间"><a href="#6-1-2、最大不相交区间" class="headerlink" title="6.1.2、最大不相交区间"></a>6.1.2、最大不相交区间</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定 <span class="hljs-built_in">N</span>个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。<br>输出可选取区间的最大数量。<br>输入格式<br>第一行包含整数 <span class="hljs-built_in">N</span>，表示区间数。<br>接下来 <span class="hljs-built_in">N</span>行，每行包含两个整数 ai,bi，表示一个区间的两个端点。<br>输出格式<br>输出一个整数，表示可选取区间的最大数量。<br></code></pre></td></tr></table></figure>

<p>实际问题：有一系列课程，要求每节课之间都要有休息时间，求怎么安排课程能够使得课程数量最多</p>
<p>本质上还是上一题，也就是找点使得每个区间至少都要一个点，有相同点的区间看成一个集合，从每个不同的区间中选一节课，也就是说集合的个数就是最大的课程数，也就是说选的点数就是最大的课程数。不同集合之间至少有一对区间是不相交的。</p>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%8C%BA%E9%97%B4.png" srcset="/img/loading.gif" lazyload></p>
<p>代码和上一题一模一样</p>
<h5 id="6-1-3、区间分组"><a href="#6-1-3、区间分组" class="headerlink" title="6.1.3、区间分组"></a>6.1.3、区间分组</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定 <span class="hljs-built_in">N</span>个闭区间 [ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。<br>输出最小组数。<br>输入格式<br>第一行包含整数 <span class="hljs-built_in">N</span>，表示区间数。<br>接下来 <span class="hljs-built_in">N</span>行，每行包含两个整数 ai,bi，表示一个区间的两个端点。<br></code></pre></td></tr></table></figure>



<p>思路:</p>
<ul>
<li>按区间左端点进行排序</li>
<li>依次遍历每个区间，用一个小根堆维护每组区间右端点的最大值max_r，例如：</li>
</ul>
<p>-———— 6</p>
<p>​                    ————10</p>
<p>​                      -–—-8</p>
<p>​                                 -————11</p>
<p>这种情况分为两组，上边一组的max_r为10，下边一组的max_r为11</p>
<p>而每次cur_l就是与当前所有max_r当中最小的那个（在这里是10）比较，如果cur_l&gt;max_r,则把这个区间放进这一组并更新这一组的max_r ；反之，则创建一个新区间，并把这个新区间的max_r加入小根堆</p>
<p>每次与所有区间组max_r的最小值比较，就保证了如果cur_l&lt;max_r的话，cur_l一定小于所有组的max_r，同时又因为左端点升序排序，则保证了此时该区间一定与所有区间组都有交集，那么一定要创建新的组</p>
<p><img src="/../../../Desktop/%E6%80%BB/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br>rang = []<br>max_r = []<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        rang.append((a, b))<br>    rang.sort(key = <span class="hljs-keyword">lambda</span> x : x[<span class="hljs-number">0</span>])    <span class="hljs-comment">#  排序</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        l, r = rang[i]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(max_r) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> l &lt;= max_r[<span class="hljs-number">0</span>]:<br>            heapq.heappush(max_r, r)<br>        <span class="hljs-keyword">else</span>:<br>            heapq.heappop(max_r)<br>            heapq.heappush(max_r, r)<br>    res = <span class="hljs-built_in">len</span>(max_r)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<h5 id="6-1-4、区间覆盖"><a href="#6-1-4、区间覆盖" class="headerlink" title="6.1.4、区间覆盖"></a>6.1.4、区间覆盖</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">给定 N个区间 <span class="hljs-selector-attr">[ai,bi]</span>以及一个区间 <span class="hljs-selector-attr">[s,t]</span>，请你选择尽量少的区间，将指定区间完全覆盖。<br>输出最少区间数，如果无法完全覆盖则输出 −<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure>



<p>思路：</p>
<ul>
<li>按左端点排序</li>
<li>记录起点st、终点ed，遍历每个区间，找到能够覆盖st的区间的最大右端点max_r，并将st更新为max_r，不断重复，直至st大于ed</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">rang = []<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    st, ed = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        rang.append((a, b))<br>    rang.sort(key = <span class="hljs-keyword">lambda</span> x : x[<span class="hljs-number">0</span>])    <span class="hljs-comment"># 按左端点排序</span><br>    <br>    i = <span class="hljs-number">0</span><br>    res = <span class="hljs-number">0</span><br>    flag = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; n:<br>        j = i<br>        max_r = -<span class="hljs-number">0x3f3f3f3f</span><br>        <span class="hljs-keyword">while</span> j &lt; n:             <span class="hljs-comment"># 找到覆盖st的最大右端点</span><br>            l , r = rang[j]<br>            <span class="hljs-keyword">if</span> l &lt;= st:<br>                max_r = <span class="hljs-built_in">max</span>(max_r, r)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>            j += <span class="hljs-number">1</span><br>        i = j<br>        <span class="hljs-keyword">if</span> max_r &lt; st:   <br>            <span class="hljs-keyword">break</span>  <br>        st = max_r     <br>        res += <span class="hljs-number">1</span>       <br>        <span class="hljs-keyword">if</span> st &gt;= ed:     <br>            flag = <span class="hljs-number">1</span>  <br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(res)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>





<h4 id="6-2、排序不等式"><a href="#6-2、排序不等式" class="headerlink" title="6.2、排序不等式"></a>6.2、排序不等式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">有 n个人排队到 <span class="hljs-number">1</span>个水龙头处打水，第 <span class="hljs-selector-tag">i</span>个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？<br></code></pre></td></tr></table></figure>

<p>类似于操作系统，就是让耗时少的人先打水</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    s = [<span class="hljs-number">0</span>] + <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    s.sort()<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        res += s[i] * (n - i)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<h4 id="6-3-绝对值不等式"><a href="#6-3-绝对值不等式" class="headerlink" title="6.3 绝对值不等式"></a>6.3 绝对值不等式</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">在一条数轴上有 N家商店，它们的坐标分别为 <span class="hljs-built_in">A1</span>∼AN。<br>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。<br>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。<br></code></pre></td></tr></table></figure>

<p>对于奇数，直接选中位数；对于偶数，选中间两个数或者是中间两个数之间的数都行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    s.sort()<br>    sm = s[n // <span class="hljs-number">2</span>]<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        res += <span class="hljs-built_in">abs</span>(s[i] - sm)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>



<h4 id="6-4、推公式"><a href="#6-4、推公式" class="headerlink" title="6.4、推公式"></a>6.4、推公式</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">农民约翰的 <span class="hljs-built_in">N</span>头奶牛（编号为 <span class="hljs-number">1</span>..<span class="hljs-built_in">N</span>）计划逃跑并加入马戏团，为此它们决定练习表演杂技。<br>奶牛们不是非常有创意，只提出了一个杂技表演：<br>叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。<br>奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。<br>这<span class="hljs-built_in">N</span>头奶牛中的每一头都有着自己的重量 Wi以及自己的强壮程度 Si。<br>一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。<br>您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。<br></code></pre></td></tr></table></figure>



<p>要让越下面的奶牛体重越大，越强壮，所以考虑按照体重+强壮系数来排序，越大的在越下面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    s = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>        s.append((a, b))<br>    s.sort(key = <span class="hljs-keyword">lambda</span> x : x[<span class="hljs-number">1</span>] + x[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    res = -<span class="hljs-number">0x3f3f3f3f</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = s[i]<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">sum</span> - b)<br>        <span class="hljs-built_in">sum</span> += a <br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>acwing算法基础课笔记总结</div>
      <div>http://example.com/2025/04/11/acwing算法基础课笔记总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>liujunhao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年4月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/05/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" title="博客搭建">
                        <span class="hidden-mobile">博客搭建</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
